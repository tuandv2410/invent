{"version":3,"file":"automapper.esm.js","sources":["../src/conventions/camel-case-naming-convention.ts","../src/conventions/snake-case-naming-convention.ts","../src/conventions/pascal-case-naming-convention.ts","../src/conventions/index.ts","../src/error-handler.ts","../src/storages/base-storage.ts","../src/storages/mapping.storage.ts","../src/storages/metadata.storage.ts","../src/storages/profile.storage.ts","../src/storages/instance.storage.ts","../src/utils/storeMetadata.ts","../src/utils/isEmpty.ts","../src/utils/isClass.ts","../src/utils/isThisMemberMap.ts","../src/utils/get.ts","../src/utils/getSourcePropertyKey.ts","../src/utils/getMemberPath.ts","../src/member-functions/map-initialize.ts","../src/core/instantiate.ts","../src/core/initialize-mapping-props.ts","../src/core/create-mapping-object.ts","../src/core/get-mapping-for-destination.ts","../src/core/inherit-base-mapping.ts","../src/core/initialize-reverse-mapping-props.ts","../src/core/create-reverse-mapping-object.ts","../src/core/create-map-for-member.ts","../src/core/create-reverse-map-fluent-function.ts","../src/core/create-map-fluent-function.ts","../src/core/get-mapping-for-nested-key.ts","../src/core/get-map-props.ts","../src/core/map.ts","../src/explorers/metadata.explorer.ts","../src/automapper.ts","../src/create-map-metadata.ts","../src/decorators/automap.decorator.ts","../src/member-functions/map-from.ts","../src/member-functions/map-with.ts","../src/member-functions/condition.ts","../src/member-functions/from-value.ts","../src/member-functions/convert-using.ts","../src/member-functions/null-substitution.ts","../src/member-functions/pre-condition.ts","../src/member-functions/ignore.ts","../src/member-functions/map-defer.ts","../src/profile-base.ts"],"sourcesContent":["import { NamingConvention } from '../types';\n\n/**\n * camelCase naming convention\n */\nexport class CamelCaseNamingConvention implements NamingConvention {\n  separatorCharacter = '';\n  splittingExpression: RegExp = /(^[a-z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n\n  public transformPropertyName(sourceNameParts: string[]): string {\n    let result = '';\n\n    for (let i = 0, len = sourceNameParts.length; i < len; i++) {\n      if (i === 0) {\n        result += sourceNameParts[i].charAt(0).toLowerCase();\n      } else {\n        result += sourceNameParts[i].charAt(0).toUpperCase();\n      }\n\n      result += sourceNameParts[i].substr(1);\n    }\n\n    return result;\n  }\n}\n","import { NamingConvention } from '../types';\n\nexport class SnakeCaseNamingConvention implements NamingConvention {\n  separatorCharacter: string = '_';\n  splittingExpression: RegExp = /_/;\n\n  public transformPropertyName(sourcePropNameParts: string[]): string {\n    const len = sourcePropNameParts.length;\n\n    if (len <= 1) {\n      return sourcePropNameParts[0].toLowerCase() || '';\n    }\n\n    return sourcePropNameParts\n      .map(p => p.toLowerCase())\n      .join(this.separatorCharacter);\n  }\n}\n","import { NamingConvention } from '../types';\n\n/**\n * PascalCase naming convention\n */\nexport class PascalCaseNamingConvention implements NamingConvention {\n  separatorCharacter = '';\n  splittingExpression: RegExp = /(^[A-Z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n\n  public transformPropertyName(sourceNameParts: string[]): string {\n    let result = '';\n\n    for (let i = 0, len = sourceNameParts.length; i < len; i++) {\n      result +=\n        sourceNameParts[i].charAt(0).toUpperCase() +\n        sourceNameParts[i].substr(1);\n    }\n\n    return result;\n  }\n}\n","import { CamelCaseNamingConvention } from './camel-case-naming-convention';\n\nexport * from './snake-case-naming-convention';\nexport * from './camel-case-naming-convention';\nexport * from './pascal-case-naming-convention';\nexport const defaultNamingConvention = CamelCaseNamingConvention;\n","export class ErrorHandler {\n  private static shouldThrow = true;\n\n  static setShouldThrow(shouldThrow: boolean): void {\n    this.shouldThrow = shouldThrow;\n  }\n\n  static handleError(errorMessage: string): void {\n    if (this.shouldThrow) {\n      throw new Error(errorMessage);\n    } else {\n      console.warn(errorMessage);\n      return;\n    }\n  }\n}\n","export abstract class NestStorage<\n  TKey extends object = any,\n  TValue = unknown,\n  TNestedMap extends Map<any, TValue> | WeakMap<TKey, TValue> = any\n> {\n  protected storage: WeakMap<TKey, TNestedMap>;\n\n  protected constructor() {\n    this.storage = new WeakMap<TKey, TNestedMap>();\n  }\n\n  set(key: TKey, nestedKey: any, value: TValue): void {\n    this.setInternal(this.storage, key, nestedKey, value);\n  }\n\n  get(key: TKey, nestedKey: any): TValue | undefined {\n    return this.getInternal(this.storage, key, nestedKey);\n  }\n\n  has(key: TKey, nestedKey: any): boolean {\n    return this.hasInternal(this.storage, key, nestedKey);\n  }\n\n  protected getInternal<\n    TKey extends object = any,\n    TValue = unknown,\n    TNestedMap extends Map<any, TValue> | WeakMap<TKey, TValue> = any\n  >(\n    storage: WeakMap<TKey, TNestedMap>,\n    key: TKey,\n    nestedKey: any\n  ): TValue | undefined {\n    return storage.get(key)?.get(nestedKey);\n  }\n\n  protected hasInternal<\n    TKey extends object = any,\n    TValue = unknown,\n    TNestedMap extends Map<any, TValue> | WeakMap<TKey, TValue> = any\n  >(storage: WeakMap<TKey, TNestedMap>, key: TKey, nestedKey: any): boolean {\n    return storage.get(key)?.has(nestedKey) || false;\n  }\n\n  protected abstract setInternal<TKey extends object = any, TValue = unknown>(\n    storage: WeakMap<TKey, any>,\n    key: TKey,\n    nestedKey: any,\n    value: TValue\n  ): void;\n}\n\nexport abstract class WeakMapNestedStorage<\n  TKey extends object = any,\n  TValue = unknown\n> extends NestStorage<TKey, TValue, WeakMap<TKey, TValue>> {\n  protected constructor() {\n    super();\n  }\n\n  dispose(): void {\n    this.storage = new WeakMap<TKey, WeakMap<TKey, TValue>>();\n  }\n\n  protected setInternal<TKey extends object = any, TValue = unknown>(\n    storage: WeakMap<TKey, WeakMap<TKey, TValue>>,\n    key: TKey,\n    nestedKey: TKey,\n    value: TValue\n  ) {\n    if (!storage.has(key)) {\n      storage.set(key, new WeakMap<TKey, TValue>().set(nestedKey, value));\n      return;\n    }\n\n    if (!this.hasInternal(storage, key, nestedKey)) {\n      storage.get(key)!.set(nestedKey, value);\n    }\n  }\n}\n\nexport abstract class MapNestedStorage<\n  TKey extends object = any,\n  TValue = unknown\n> extends NestStorage<TKey, TValue, Map<any, TValue>> {\n  protected constructor() {\n    super();\n  }\n\n  protected setInternal<TKey extends object = any, TValue = unknown>(\n    storage: WeakMap<TKey, Map<any, TValue>>,\n    key: TKey,\n    nestedKey: unknown,\n    value: TValue\n  ) {\n    if (!storage.has(key)) {\n      storage.set(key, new Map<any, TValue>().set(nestedKey, value));\n      return;\n    }\n\n    if (!this.hasInternal(storage, key, nestedKey)) {\n      storage.get(key)!.set(nestedKey, value);\n    }\n  }\n}\n","import { Constructible, Mapping } from '../types';\nimport { WeakMapNestedStorage } from './base-storage';\n\n/**\n * Internal MappingStorage class\n * @private\n */\nexport class MappingStorage extends WeakMapNestedStorage<\n  Constructible,\n  Mapping\n> {\n  constructor() {\n    super();\n  }\n}\n","import { Constructible, Dict, MetadataMap, MetadataMapList } from '../types';\n\n/**\n * Internal MetadataStorage class\n *\n * @private\n */\nclass MetadataStorage {\n  private _metadataMap = new Map<Constructible, MetadataMapList>();\n\n  getMetadata<TModel extends Dict<TModel> = any>(\n    model: Constructible<TModel>\n  ): MetadataMapList<TModel> {\n    const metadataMapList = this._metadataMap.get(model) as MetadataMapList<\n      TModel\n    >;\n    let i = metadataMapList?.length || 0;\n\n    if (!i) {\n      const proto = Object.getPrototypeOf(model);\n      return proto ? this.getMetadata(proto) : metadataMapList;\n    }\n\n    const result: MetadataMapList<TModel> = [];\n    while (i--) {\n      const [key] = metadataMapList[i];\n      if (result.some(([metaKey]) => metaKey === key)) {\n        continue;\n      }\n      result.push(metadataMapList[i]);\n    }\n    return result;\n  }\n\n  getMetadataForKey<TModel extends Dict<TModel> = any>(\n    model: Constructible<TModel>,\n    key: keyof TModel\n  ): MetadataMap<TModel> | undefined {\n    return this.getMetadata(model).find(([metaKey]) => metaKey === key);\n  }\n\n  addMetadata<TModel extends Dict<TModel> = any>(\n    model: Constructible<TModel>,\n    metadata: MetadataMapList<TModel>\n  ) {\n    const existingMetadata = this._metadataMap.get(model) || [];\n    const proto = Object.getPrototypeOf(model);\n    const existingProtoMetadata =\n      proto && !!proto.name ? this._metadataMap.get(proto) || [] : [];\n\n    const existingMeta = [...existingProtoMetadata, ...existingMetadata];\n\n    for (let [existKey] of existingMeta) {\n      const [key] = metadata[0];\n      if (key === existKey) {\n        return;\n      }\n    }\n\n    this._metadataMap.set(model, [...existingMeta, ...metadata]);\n  }\n}\n\nexport const metadataStorage = new MetadataStorage();\n","import { AutoMapper } from '../automapper';\nimport { ErrorHandler } from '../error-handler';\nimport { MappingProfile } from '../types';\n\n/**\n * Internal ProfileStorage class\n *\n * @private\n */\nexport class ProfileStorage {\n  private profiles: WeakMap<AutoMapper, MappingProfile[]>;\n\n  constructor() {\n    this.profiles = new WeakMap<AutoMapper, MappingProfile[]>();\n  }\n\n  /**\n   * Initialize a Mapper instance with an empty profiles array\n   *\n   * @param {AutoMapper} mapper - Mapper instance to initialize\n   */\n  initialize(mapper: AutoMapper): void {\n    this.profiles.set(mapper, []);\n  }\n\n  /**\n   * Add a MappingProfile to a Mapper instance\n   *\n   * @param {AutoMapper} mapper - Mapper instance to initialize\n   * @param {MappingProfile} profile - MappingProfile to add to the mapper instance\n   */\n  add(mapper: AutoMapper, profile: MappingProfile): void {\n    const profiles = this.profiles.get(mapper) as MappingProfile[];\n    if (profiles.some(p => p.profileName === profile.profileName)) {\n      ErrorHandler.handleError(\n        `${profile.profileName} already exists on this mapper instance`\n      );\n    }\n\n    profiles.push(profile);\n  }\n}\n","/**\n * Internal InstanceStorage class\n * @private\n */\nimport { Constructible } from '../types';\nimport { MapNestedStorage } from './base-storage';\n\nclass InstanceStorage extends MapNestedStorage<Constructible, number> {\n  private recursiveCounts: WeakMap<Constructible, Map<string, number>>;\n\n  constructor() {\n    super();\n    this.recursiveCounts = new WeakMap<Constructible, Map<string, number>>();\n  }\n\n  getDepthAndCount(\n    parent: Constructible,\n    member: string\n  ): [number | undefined, number | undefined] {\n    return [this.get(parent, member), this.getCount(parent, member)];\n  }\n\n  setCount(parent: Constructible, member: string, count: number) {\n    if (this.recursiveCounts.has(parent)) {\n      this.recursiveCounts.get(parent)!.set(member, count);\n    } else {\n      this.setInternal(this.recursiveCounts, parent, member, count);\n    }\n  }\n\n  resetCount(parent: Constructible, member: string) {\n    this.recursiveCounts.get(parent)?.set(member, 0);\n  }\n\n  resetAllCount(model: Constructible) {\n    this.recursiveCounts.get(model)?.clear();\n  }\n\n  private getCount(parent: Constructible, member: string): number | undefined {\n    return this.getInternal(this.recursiveCounts, parent, member);\n  }\n\n  dispose() {\n    this.recursiveCounts = new WeakMap<Constructible, Map<string, number>>();\n  }\n}\n\nexport const instanceStorage = new InstanceStorage();\n","import { metadataStorage } from '../storages';\nimport { Constructible, Dict } from '../types';\n\nexport function storeMetadata<TModel extends Dict<TModel> = any>(\n  model: Constructible<TModel>,\n  metaName: string,\n  metaKey: string,\n  metaValue?: any\n) {\n  switch (metaName) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n      metadataStorage.addMetadata(model, [[metaKey, () => false]]);\n      break;\n    case 'Date':\n      metadataStorage.addMetadata(model, [[metaKey, () => Date]]);\n      break;\n    case 'Array':\n      metadataStorage.addMetadata(model, [[metaKey, () => []]]);\n      break;\n    default:\n      metadataStorage.addMetadata(model, [[metaKey, () => metaValue]]);\n      break;\n  }\n}\n","export function isEmpty(value: any): boolean {\n  if (Array.isArray(value)) {\n    return !value.length;\n  }\n\n  return !value || !Object.keys(value).length;\n}\n","export function isClass(fn: Function | Object): boolean {\n  const typeOfFn = typeof fn;\n  const constructorFnString = fn.constructor?.toString();\n  return (\n    (typeOfFn === 'object' || typeOfFn === 'function') &&\n    fn.constructor &&\n    (/^\\s*function/.test(constructorFnString) ||\n      /^\\s*class/.test(constructorFnString)) &&\n    constructorFnString.includes(fn.constructor.name)\n  );\n}\n","import {\n  MemberMapFunction,\n  MemberMapFunctionId,\n  TransformationType,\n} from '../types';\n\n// TODO(chau): use Variadic Tuple Type when upgrade to TypeScript 4.1\nexport function isThisMemberMap<TMemberMap extends MemberMapFunction>(\n  mapFn: ReturnType<MemberMapFunction>,\n  type: TransformationType\n): mapFn is ReturnType<TMemberMap>;\nexport function isThisMemberMap<\n  TMemberMapA extends MemberMapFunction,\n  TMemberMapB extends MemberMapFunction\n>(\n  mapFn: ReturnType<MemberMapFunction>,\n  typeA: TransformationType,\n  typeB: TransformationType\n): mapFn is ReturnType<TMemberMapA | TMemberMapB>;\nexport function isThisMemberMap<\n  TMemberMapA extends MemberMapFunction,\n  TMemberMapB extends MemberMapFunction,\n  TMemberMapC extends MemberMapFunction\n>(\n  mapFn: ReturnType<MemberMapFunction>,\n  typeA: TransformationType,\n  typeB: TransformationType,\n  typeC: TransformationType\n): mapFn is ReturnType<TMemberMapA | TMemberMapB | TMemberMapC>;\nexport function isThisMemberMap(\n  mapFn: ReturnType<MemberMapFunction>,\n  ...types: TransformationType[]\n) {\n  return types.some(type => mapFn[MemberMapFunctionId.type] === type);\n}\n","export function get<T>(\n  object: T,\n  defaultVal: unknown,\n  ...paths: string[]\n): any {\n  function _getInternal(object: T, path: string) {\n    const _path = path.split('.').filter(Boolean);\n    const _val = _path.reduce((obj: any, key) => obj && obj[key], object);\n    return _val != null ? _val : defaultVal;\n  }\n\n  let val = _getInternal(object, paths[0]);\n  for (let i = 1, len = paths.length; i < len; i++) {\n    if (val != null) {\n      val = _getInternal(val, paths[i]);\n      continue;\n    }\n    val = _getInternal(object, paths[i]);\n  }\n\n  return val;\n}\n","import { Constructible, NamingConvention } from '../types';\n\nexport function getSourcePropertyKey(\n  [sourceNamingConvention, destinationNamingConvention]: [\n    Constructible<NamingConvention>,\n    Constructible<NamingConvention>\n  ],\n  path: string\n): string {\n  const splitPath = path.split('.');\n  if (splitPath.length > 1) {\n    return splitPath\n      .map(key =>\n        getSourcePropertyKey(\n          [sourceNamingConvention, destinationNamingConvention],\n          key\n        )\n      )\n      .join('.');\n  }\n\n  const destNamingConvention = new destinationNamingConvention();\n  const srcNamingConvention = new sourceNamingConvention();\n  const keyParts = path\n    .split(destNamingConvention.splittingExpression)\n    .filter(Boolean);\n  return !keyParts.length\n    ? path\n    : srcNamingConvention.transformPropertyName(keyParts);\n}\n","import { Selector } from '../types';\n\n/**\n * https://github.com/IRCraziestTaxi/ts-simple-nameof\n * This implementation is copied from the linked library.\n *\n * Old implementation:\n *\n if (/^[^{]+?=>/gm.test(fnString)) {\n    let value: string[];\n    const _parts = fnString\n      .replace(/(?:\\s|;|{|}|\\(|\\)|)+/gm, '')\n      .split(/=>(.+)/);\n    const _returnPart = _parts[1];\n    const _returnMatches = _returnPart.match(/return/g);\n\n    if (_returnMatches?.length && _returnMatches.length > 1) {\n      value = [_parts[0]].concat(\n        ..._returnPart.split(/return(.+)/).filter(Boolean)\n      );\n    } else {\n      value = _parts;\n    }\n\n    return getPathFromSelector(value);\n  }\n  return getPathFromSelector(\n    fnString.replace(/(?:\\s|function|;|{|}|\\(|\\)|)+/gm, '').split(/return(.+)/)\n  );\n\n  function getPathFromSelector(fnParts: string[]): string {\n  const [, ...parts] = fnParts\n    .join('')\n    .split(new RegExp(`${fnParts[0]}\\\\.{1}`, 'g'))\n    .filter(Boolean);\n\n  if (parts.length === 1) {\n    return parts.pop() as string;\n  }\n\n  return '';\n}\n */\nexport function getMemberPath(fn: Selector): string {\n  const fnString = fn.toString();\n\n  // ES6 prop selector:\n  // \"x => x.prop\"\n  if (fnString.includes('=>')) {\n    return cleanseAssertionOperators(\n      fnString.substring(fnString.indexOf('.') + 1)\n    );\n  }\n\n  // ES5 prop selector:\n  // \"function (x) { return x.prop; }\"\n  // webpack production build excludes the spaces and optional trailing semicolon:\n  //   \"function(x){return x.prop}\"\n  // FYI - during local dev testing i observed carriage returns after the curly brackets as well\n  // Note by maintainer: See https://github.com/IRCraziestTaxi/ts-simple-nameof/pull/13#issuecomment-567171802 for\n  // explanation of this regex.\n  const matchRegex = /function\\s*\\(\\w+\\)\\s*{[\\r\\n\\s]*return\\s+\\w+\\.((\\w+\\.)*(\\w+))/i;\n\n  const es5Match = fnString.match(matchRegex);\n\n  if (es5Match) {\n    return es5Match[1]!;\n  }\n\n  return '';\n}\n\nfunction cleanseAssertionOperators(parsedName: string): string {\n  return parsedName.replace(/[?!]/g, '').replace(/(?:\\s|;|{|}|\\(|\\)|)+/gm, '');\n}\n","import {\n  Dict,\n  MapInitializeFunction,\n  SelectorReturn,\n  TransformationType,\n} from '../types';\nimport { get } from '../utils';\n\nexport function mapInitialize<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  defaultVal: undefined | null,\n  ...paths: string[]\n): ReturnType<MapInitializeFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    TransformationType.MapInitialize,\n    null,\n    source => get(source, defaultVal, ...paths),\n  ];\n}\n","import { instanceStorage, metadataStorage } from '../storages';\nimport { Constructible, Dict } from '../types';\nimport { isEmpty } from '../utils';\n\nexport function instantiate<TModel extends Dict<TModel>>(\n  model: Constructible<TModel>,\n  defaultValue?: TModel\n): TModel {\n  const metadata = metadataStorage.getMetadata(model);\n\n  const instance = (defaultValue\n    ? Object.assign(new model(), defaultValue)\n    : new model()) as any;\n  if (isEmpty(metadata) || !metadata) {\n    return instance;\n  }\n\n  let i = metadata.length;\n  while (i--) {\n    const [key, meta] = metadata[i];\n    const value = instance[key];\n    const metaResult = meta();\n    if (!metaResult) {\n      instance[key] = value != null ? value : undefined;\n      continue;\n    }\n\n    if (Array.isArray(metaResult)) {\n      instance[key] = value != null ? value : metaResult;\n      continue;\n    }\n\n    if (\n      metaResult.prototype.constructor.name === 'Date' ||\n      metaResult.prototype.constructor.name === 'Moment'\n    ) {\n      instance[key] = value != null ? new metaResult(value) : new metaResult();\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      instance[key] = value.map(v => instantiate(metaResult, v));\n      continue;\n    }\n\n    if (value == null && defaultValue != null) {\n      instance[key] = value;\n      continue;\n    }\n\n    if (value != null) {\n      instance[key] = instantiate(metaResult, value);\n      continue;\n    }\n\n    const [depth, count = 0] = instanceStorage.getDepthAndCount(model, key);\n\n    if (depth === 0) {\n      instance[key] = new metaResult();\n      continue;\n    }\n\n    if (depth === count) {\n      instanceStorage.resetCount(model, key);\n      instance[key] = new metaResult();\n      continue;\n    }\n\n    instanceStorage.setCount(model, key, count != null ? count + 1 : 1);\n    instance[key] = instantiate(metaResult, value);\n  }\n\n  instanceStorage.resetAllCount(model);\n  return instance;\n}\n","import { mapInitialize } from '../member-functions/map-initialize';\nimport { Dict, Mapping, MappingClassId } from '../types';\nimport { getSourcePropertyKey, isClass } from '../utils';\nimport { instantiate } from './instantiate';\n\nexport function initializeMappingProps<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(mapping: Mapping<TSource, TDestination>): void {\n  const [srcModel, destModel] = mapping[MappingClassId.models];\n  const destination = instantiate(destModel);\n  let source = instantiate(srcModel);\n  const sourceProtoConstructor = Object.getPrototypeOf(source.constructor);\n  if (sourceProtoConstructor.name) {\n    source = Object.assign(source, instantiate(sourceProtoConstructor));\n  }\n\n  const sourceProto = Object.getPrototypeOf(source);\n  const destinationPaths = getPathRecursive(destination);\n  const [\n    useUndefined,\n    sourceNamingConvention,\n    destinationNamingConvention,\n  ] = mapping[MappingClassId.conventions];\n  let i = destinationPaths.length;\n  while (i--) {\n    const path = destinationPaths[i];\n    const sourcePath = getSourcePropertyKey(\n      [sourceNamingConvention, destinationNamingConvention],\n      path\n    );\n    const dottedSourcePaths = sourcePath.split('.');\n    if (\n      dottedSourcePaths.length > 1 &&\n      (!source.hasOwnProperty(dottedSourcePaths[0]) ||\n        ((source as any)[dottedSourcePaths[0]] &&\n          isClass((source as any)[dottedSourcePaths[0]])))\n    ) {\n      continue;\n    }\n\n    const defaultVal = useUndefined ? undefined : null;\n    if (\n      !source.hasOwnProperty(sourcePath) &&\n      !sourceProto.hasOwnProperty(sourcePath)\n    ) {\n      const convention = new sourceNamingConvention();\n      const [first, ...paths] = sourcePath\n        .split(convention.splittingExpression)\n        .filter(Boolean)\n        .filter(p => p !== '.');\n      if (!paths.length || !source.hasOwnProperty(first)) {\n        continue;\n      }\n\n      const sourceMemberPath = [\n        [first]\n          .concat(paths.map(p => convention.transformPropertyName([p])))\n          .join('.'),\n      ];\n\n      if (paths.length > 1) {\n        sourceMemberPath.push(\n          [first].concat(convention.transformPropertyName(paths)).join('.')\n        );\n      }\n\n      mapping[MappingClassId.props].push([\n        path,\n        Object.seal({\n          paths: [path],\n          transformation: {\n            type: 6, // 6: TransformationType.MapInitialize.\n            preCond: undefined,\n            mapFn: mapInitialize(defaultVal, ...sourceMemberPath),\n          },\n        }),\n      ]);\n      continue;\n    }\n\n    mapping[MappingClassId.props].push([\n      path,\n      Object.seal({\n        paths: [path, sourcePath],\n        transformation: {\n          type: 6, // 6: TransformationType.MapInitialize.\n          preCond: undefined,\n          mapFn: mapInitialize(defaultVal, sourcePath),\n        },\n      }),\n    ]);\n  }\n}\n\nfunction getPathRecursive(node: any, prefix: string = '', prev?: string[]) {\n  let result: string[] = prev || [];\n\n  const keys = Object.getOwnPropertyNames(node);\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n    const path = prefix + key;\n    result.push(path);\n\n    const child = node[key];\n    if (typeof child === 'object') {\n      let queue = [child];\n      if (Array.isArray(child)) {\n        queue = child;\n      }\n\n      for (const childNode of queue) {\n        const childPaths = getPathRecursive(childNode, path + '.');\n        for (const childPath of childPaths) {\n          result.push(childPath);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { ErrorHandler } from '../error-handler';\nimport { MappingStorage } from '../storages';\nimport {\n  BaseOf,\n  Constructible,\n  CreateMapOptions,\n  Dict,\n  Mapping,\n} from '../types';\nimport { initializeMappingProps } from './initialize-mapping-props';\n\nexport function createMappingObject<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  source: Constructible<TSource>,\n  destination: Constructible<TDestination>,\n  options: CreateMapOptions<\n    TSource,\n    TDestination,\n    TBaseSource,\n    TBaseDestination\n  >,\n  mappingStorage: MappingStorage\n) {\n  if (mappingStorage.has(source, destination)) {\n    ErrorHandler.handleError(\n      `Mapping for source ${source.toString()} and destination ${destination.toString()} already exists`\n    );\n  }\n\n  const mapping: Mapping<\n    TSource,\n    TDestination,\n    TBaseSource,\n    TBaseDestination\n  > = [\n    [source, destination],\n    [\n      options.useUndefined!,\n      options.sourceMemberNamingConvention!,\n      options.destinationMemberNamingConvention!,\n    ],\n    [],\n    [],\n  ];\n  initializeMappingProps(mapping);\n  mappingStorage.set(source, destination, mapping);\n  return mapping;\n}\n","import { MappingStorage } from '../storages';\nimport { Constructible, Dict, Mapping } from '../types';\n\nexport function getMappingForDestination<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  destination: Constructible<TDestination>,\n  source: Constructible<TSource>,\n  mappingStorage: MappingStorage,\n  isInherit: boolean = false\n): Mapping<TSource, TDestination> | undefined | never {\n  const mapping = mappingStorage.get(source, destination);\n\n  if (!mapping && !isInherit) {\n    throw new Error(\n      `Mapping not found for source ${source.toString()} and destination ${destination.toString()}`\n    );\n  }\n\n  return mapping as Mapping<TSource, TDestination>;\n}\n","import {\n  BaseOf,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MappingProperty,\n} from '../types';\n\nexport function inheritBaseMapping<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>,\n  baseMapping: Mapping<TBaseSource, TBaseDestination>\n) {\n  const props = mapping[MappingClassId.props];\n  const baseProps = baseMapping[MappingClassId.props];\n  for (let i = 0, len = baseProps.length; i < len; i++) {\n    const [basePropKey, baseProp] = baseProps[i];\n    const propFromBase = Object.seal({ ...baseProp }) as MappingProperty;\n    const existProp = props.find(([pKey]) => pKey === basePropKey);\n    if (existProp) {\n      existProp[0] = basePropKey;\n      existProp[1] = propFromBase;\n    } else {\n      props.push([basePropKey, propFromBase]);\n    }\n  }\n  mapping[MappingClassId.bases] = [\n    baseMapping[MappingClassId.models][0],\n    baseMapping[MappingClassId.models][1],\n  ];\n}\n","import { mapInitialize } from '../member-functions/map-initialize';\nimport {\n  BaseOf,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MappingProperty,\n  MemberMapFunctionId,\n  Selector,\n} from '../types';\nimport { getMemberPath } from '../utils';\nimport { instantiate } from './instantiate';\n\nexport function initializeReverseMappingProps<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>\n): Array<\n  [\n    string,\n    MappingProperty<TDestination, TSource, ReturnType<Selector<TSource>>>\n  ]\n> {\n  const model = instantiate(mapping[MappingClassId.models][0]);\n  const proto = Object.getPrototypeOf(model);\n  const reversedProps: Array<[\n    string,\n    MappingProperty<TDestination, TSource, ReturnType<Selector<TSource>>>\n  ]> = [];\n\n  const props = mapping[MappingClassId.props];\n  let i = props.length;\n  while (i--) {\n    const { paths, transformation } = props[i][1];\n    const [destPath, sourcePath] = paths;\n\n    /**\n     * 1: TransformationType.MapFrom\n     * 4: TransformationType.MapWith\n     */\n    if (!sourcePath && transformation.type !== 1 && transformation.type !== 4) {\n      continue;\n    }\n\n    let path = '';\n    if (sourcePath) {\n      path = sourcePath;\n    } else {\n      path = getMemberPath(\n        transformation.mapFn[MemberMapFunctionId.fn] as Selector\n      );\n    }\n\n    if (\n      (!model.hasOwnProperty(path) && !proto.hasOwnProperty(path)) ||\n      reversedProps.some(([propPath]) => propPath === path)\n    ) {\n      continue;\n    }\n\n    reversedProps.push([\n      path,\n      Object.seal({\n        paths: [path, destPath],\n        transformation: {\n          type: 6, // 6 is TransformationType.MapInitialize.\n          preCond: undefined,\n          mapFn: mapInitialize(\n            mapping[MappingClassId.conventions][0] ? undefined : null,\n            destPath\n          ),\n        },\n      }),\n    ]);\n  }\n\n  return reversedProps;\n}\n","import { MappingStorage } from '../storages';\nimport { BaseOf, Constructible, Dict, Mapping, MappingClassId } from '../types';\nimport { getMappingForDestination } from './get-mapping-for-destination';\nimport { inheritBaseMapping } from './inherit-base-mapping';\nimport { initializeReverseMappingProps } from './initialize-reverse-mapping-props';\n\nexport function createReverseMappingObject<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>,\n  mappingStorage: MappingStorage\n): Mapping<TDestination, TSource, TBaseDestination, TBaseSource> {\n  const [source, destination] = mapping[MappingClassId.models];\n  const [useUndefined, sourceConvention, destinationConvention] = mapping[\n    MappingClassId.conventions\n  ];\n  const bases = mapping[MappingClassId.bases];\n\n  let reversedMapping = mappingStorage.get(destination, source);\n  if (reversedMapping) {\n    return reversedMapping;\n  }\n\n  reversedMapping = [\n    [destination, source],\n    [useUndefined, destinationConvention, sourceConvention],\n    initializeReverseMappingProps(mapping),\n    [],\n    (bases?.slice().reverse() || []) as [Constructible, Constructible],\n  ];\n\n  const reversedBaseMapping = getMappingForDestination(\n    reversedMapping[MappingClassId.bases]![1],\n    reversedMapping[MappingClassId.bases]![0],\n    mappingStorage,\n    true\n  );\n  if (reversedBaseMapping) {\n    inheritBaseMapping(reversedMapping, reversedBaseMapping);\n  }\n\n  mappingStorage.set(destination, source, reversedMapping);\n  return reversedMapping;\n}\n","import {\n  Dict,\n  MapFromFunction,\n  Mapping,\n  MappingClassId,\n  MappingProperty,\n  MapWithFunction,\n  MemberMapFunction,\n  MemberMapFunctionId,\n  PreConditionFunction,\n  Selector,\n} from '../types';\nimport { getMemberPath, isThisMemberMap } from '../utils';\n\nexport function createMapForMember<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelector extends Selector<TDestination> = Selector<TDestination>,\n  TReturnType = any\n>(\n  mapping: Mapping<TSource, TDestination>,\n  selector: TSelector,\n  [preCond, mapMemberFn]: [\n    (\n      | ReturnType<PreConditionFunction<TSource, TDestination>>\n      | ReturnType<MemberMapFunction<TSource, TDestination>>\n    ),\n    ReturnType<MemberMapFunction<TSource, TDestination>>?\n  ],\n  fluentFunction: TReturnType\n): TReturnType {\n  const memberPath = getMemberPath(selector);\n\n  if (mapMemberFn == null) {\n    mapMemberFn = preCond as ReturnType<\n      MemberMapFunction<TSource, TDestination>\n    >;\n    preCond = undefined;\n  }\n\n  let sourcePath: string = '';\n  // 1: TransformationType.MapFrom\n  // 4: TransformationType.MapWith\n  if (isThisMemberMap<MapFromFunction, MapWithFunction>(mapMemberFn, 1, 4)) {\n    sourcePath = getMemberPath(mapMemberFn[MemberMapFunctionId.misc]);\n  }\n\n  const paths: [string, string?] = !!sourcePath\n    ? [memberPath, sourcePath]\n    : [memberPath];\n\n  const mappingProperty: MappingProperty<\n    TSource,\n    TDestination,\n    ReturnType<TSelector>\n  > = Object.seal({\n    paths,\n    transformation: {\n      mapFn: mapMemberFn,\n      type: mapMemberFn[MemberMapFunctionId.type],\n      preCond: preCond as ReturnType<\n        PreConditionFunction<TSource, TDestination>\n      >,\n    },\n  });\n\n  const existProp = mapping[MappingClassId.props].find(\n    ([propName]) => propName === memberPath\n  );\n  if (existProp != null) {\n    existProp[1] = mappingProperty;\n    return fluentFunction;\n  }\n\n  mapping[MappingClassId.props].push([memberPath, mappingProperty]);\n  return fluentFunction;\n}\n","import {\n  BaseOf,\n  CreateReversedMapFluentFunction,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MemberMapFunction,\n  PreConditionFunction,\n  Selector,\n  SelectorReturn,\n} from '../types';\nimport { createMapForMember } from './create-map-for-member';\n\nexport function createReverseMapFluentFunction<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TDestination, TSource, TBaseDestination, TBaseSource>\n): CreateReversedMapFluentFunction<TDestination, TSource> {\n  const reversedMapFluentFunction: CreateReversedMapFluentFunction<\n    TDestination,\n    TSource\n  > = {\n    forPath: (\n      selector: Selector<TSource, SelectorReturn<TSource>>,\n      ...functions: [\n        (\n          | ReturnType<PreConditionFunction<TDestination, TSource>>\n          | ReturnType<MemberMapFunction<TDestination, TSource>>\n        ),\n        ReturnType<MemberMapFunction<TDestination, TSource>>?\n      ]\n    ) =>\n      createMapForMember(\n        mapping,\n        selector,\n        functions as any,\n        reversedMapFluentFunction\n      ),\n    beforeMap: action => {\n      mapping[MappingClassId.actions][0] = action;\n      return reversedMapFluentFunction;\n    },\n    afterMap: action => {\n      mapping[MappingClassId.actions][1] = action;\n      return reversedMapFluentFunction;\n    },\n  };\n\n  return reversedMapFluentFunction;\n}\n","import { MappingStorage } from '../storages';\nimport {\n  BaseOf,\n  CreateMapFluentFunction,\n  CreateMapOptions,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MemberMapFunction,\n  PreConditionFunction,\n  Selector,\n  SelectorReturn,\n} from '../types';\nimport { createMapForMember } from './create-map-for-member';\nimport { createReverseMapFluentFunction } from './create-reverse-map-fluent-function';\nimport { createReverseMappingObject } from './create-reverse-mapping-object';\nimport { getMappingForDestination } from './get-mapping-for-destination';\nimport { inheritBaseMapping } from './inherit-base-mapping';\n\nexport function createMapFluentFunction<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>,\n  options: CreateMapOptions<\n    TSource,\n    TDestination,\n    TBaseSource,\n    TBaseDestination\n  >,\n  mappingStorage: MappingStorage\n): CreateMapFluentFunction<TSource, TDestination> {\n  if (options.includeBase?.length) {\n    const [baseSource, baseDestination] = options.includeBase;\n    const baseMapping = getMappingForDestination(\n      baseDestination,\n      baseSource,\n      mappingStorage,\n      true\n    );\n    if (baseMapping != null) {\n      inheritBaseMapping(mapping, baseMapping);\n    }\n  }\n\n  const fluentFunction: CreateMapFluentFunction<TSource, TDestination> = {\n    forMember: <TMemberType = SelectorReturn<TDestination>>(\n      selector: Selector<TDestination, TMemberType>,\n      ...functions: [\n        (\n          | ReturnType<PreConditionFunction<TSource, TDestination, TMemberType>>\n          | ReturnType<MemberMapFunction<TSource, TDestination, TMemberType>>\n        ),\n        ReturnType<MemberMapFunction<TSource, TDestination, TMemberType>>?\n      ]\n    ) =>\n      createMapForMember<\n        TSource,\n        TDestination,\n        Selector<TDestination, TMemberType>,\n        typeof fluentFunction\n      >(mapping, selector, functions, fluentFunction),\n    beforeMap: action => {\n      mapping[MappingClassId.actions][0] = action;\n      return fluentFunction;\n    },\n    afterMap: action => {\n      mapping[MappingClassId.actions][1] = action;\n      return fluentFunction;\n    },\n    reverseMap: () =>\n      createReverseMapFluentFunction(\n        createReverseMappingObject(mapping, mappingStorage)\n      ),\n  };\n\n  return fluentFunction;\n}\n","import { MappingStorage, metadataStorage } from '../storages';\nimport { Constructible, Dict, Mapping, MetadataMap } from '../types';\n\nexport function getMappingForNestedKey<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TDestinationKey extends keyof TDestination = any\n>(\n  destinationConstructor: Constructible<TDestination>,\n  destinationMemberKey: TDestinationKey,\n  sourceConstructor: Constructible<TSource>,\n  mappingStorage: MappingStorage\n): Mapping<TSource, TDestination[TDestinationKey]> {\n  const keyMetadata = metadataStorage.getMetadataForKey(\n    destinationConstructor,\n    destinationMemberKey\n  ) as MetadataMap<TDestination>;\n\n  const meta = keyMetadata[1]();\n  if (!meta || Array.isArray(meta)) {\n    throw new Error(\n      `Metadata for ${destinationMemberKey} is a primitive or Array. Consider manual map this property`\n    );\n  }\n\n  const mapping = mappingStorage.get(sourceConstructor, meta);\n  if (!mapping) {\n    throw new Error(\n      `Mapping for ${destinationMemberKey} cannot be found. Consider manual map this property with MapWith`\n    );\n  }\n\n  return mapping;\n}\n","import { Constructible, Dict, MapOptions } from '../types';\nimport { isClass } from '../utils';\n\nexport function getMapProps<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  args: any[],\n  skipUnmappedAssertion: boolean\n): [\n  Constructible<TDestination>,\n  MapOptions<TSource, TDestination>,\n  Constructible<TSource>?\n] {\n  const destination: Constructible<TDestination> = args[0];\n  const defaultOptions = {\n    skipUnmappedAssertion,\n    beforeMap: undefined,\n    afterMap: undefined,\n  };\n\n  if (args.length === 1) {\n    return [destination, defaultOptions];\n  }\n\n  if (args.length === 3) {\n    return [destination, { ...defaultOptions, ...args[2] }, args[1]];\n  }\n\n  let temp = args[1];\n\n  if (\n    (typeof temp === 'function' || isClass(temp)) &&\n    !temp['beforeMap'] &&\n    !temp['afterMap']\n  ) {\n    return [destination, defaultOptions, temp];\n  }\n\n  return [destination, { ...defaultOptions, ...temp }];\n}\n","import set from 'lodash.set';\nimport { MappingStorage } from '../storages';\nimport {\n  ConditionFunction,\n  ConvertUsingFunction,\n  Dict,\n  FromValueFunction,\n  IgnoreFunction,\n  MapFromFunction,\n  MapInitializeFunction,\n  MapOptions,\n  Mapping,\n  MapWithFunction,\n  MemberMapFunction,\n  MemberMapFunctionId,\n  NullSubstitutionFunction,\n} from '../types';\nimport {\n  get,\n  getSourcePropertyKey,\n  isClass,\n  isEmpty,\n  isThisMemberMap,\n} from '../utils';\nimport { getMappingForDestination } from './get-mapping-for-destination';\nimport { getMappingForNestedKey } from './get-mapping-for-nested-key';\nimport { instantiate } from './instantiate';\n\nfunction mapMember<TSource, TDestination>(\n  mapFn: ReturnType<MemberMapFunction<TSource, TDestination>>,\n  sourceObj: TSource,\n  sourceMemberPath: string,\n  destination: TDestination,\n  mappingStorage: MappingStorage,\n  defaultValue: undefined | null\n) {\n  let value: unknown;\n  /**\n   * 0: TransformationType.Ignore\n   * 1: TransformationType.MapFrom\n   * 2: TransformationType.Condition\n   * 3: TransformationType.FromValue\n   * 4: TransformationType.MapWith\n   * 5: TransformationType.ConvertUsing\n   * 7: TransformationType.NullSubstitution\n   */\n  if (isThisMemberMap<NullSubstitutionFunction>(mapFn, 7)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj, sourceMemberPath);\n  } else if (isThisMemberMap<ConditionFunction>(mapFn, 2)) {\n    value = mapFn[MemberMapFunctionId.fn](\n      sourceObj,\n      defaultValue,\n      sourceMemberPath\n    );\n  } else if (isThisMemberMap<MapFromFunction>(mapFn, 1)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj, destination);\n  } else if (isThisMemberMap<MapWithFunction>(mapFn, 4)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj, mappingStorage);\n  } else if (isThisMemberMap<ConvertUsingFunction>(mapFn, 5)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj);\n  } else if (isThisMemberMap<FromValueFunction>(mapFn, 3)) {\n    value = mapFn[MemberMapFunctionId.fn]();\n  } else if (isThisMemberMap<IgnoreFunction>(mapFn, 0)) {\n    value = defaultValue;\n  } else {\n    const memberMapFunction = mapFn[MemberMapFunctionId.fn](\n      sourceObj,\n      sourceMemberPath\n    );\n    value = mapMember(\n      memberMapFunction,\n      sourceObj,\n      sourceMemberPath,\n      destination,\n      mappingStorage,\n      defaultValue\n    );\n  }\n\n  return value;\n}\n\nexport function map<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  sourceObj: TSource,\n  mapping: Mapping<TSource, TDestination>,\n  options: MapOptions<TSource, TDestination>,\n  mappingStorage: MappingStorage,\n  isArrayMap: boolean = false\n): TDestination {\n  const [\n    [sourceModel, destinationModel],\n    [useUndefined, sourceConvention, destinationConvention],\n    props,\n    actions,\n  ] = mapping as Required<Mapping<TSource, TDestination>>;\n\n  /**\n   * If sourceObj is a POJO (plain object)\n   * then instantiate it to become an instance of sourceModel\n   */\n  if (!(sourceObj instanceof sourceModel)) {\n    sourceObj = instantiate(sourceModel, sourceObj);\n  }\n\n  const defaultEmptyValue = useUndefined ? undefined : null;\n  const [beforeAction, afterAction] = actions;\n  const { skipUnmappedAssertion, beforeMap, afterMap } = options;\n  const configKeys: string[] = [];\n\n  const destination = instantiate(destinationModel);\n\n  if (!isArrayMap) {\n    if (beforeMap) {\n      beforeMap(sourceObj, destination, { ...mapping } as any);\n    } else if (beforeAction) {\n      beforeAction(sourceObj, destination, { ...mapping } as any);\n    }\n  }\n\n  let i = props.length;\n  while (i--) {\n    const [memberPath, { transformation }] = props[i];\n    configKeys.push(memberPath);\n\n    if (transformation.preCond && !transformation.preCond[0](sourceObj)) {\n      set(\n        destination,\n        memberPath,\n        transformation.preCond[1] ?? defaultEmptyValue\n      );\n      continue;\n    }\n\n    const sourceMemberPath = getSourcePropertyKey(\n      [sourceConvention, destinationConvention],\n      memberPath\n    );\n\n    // 6: TransformationType.MapInitialize\n    if (isThisMemberMap<MapInitializeFunction>(transformation.mapFn, 6)) {\n      const mapInitializeValue = transformation.mapFn[MemberMapFunctionId.fn](\n        sourceObj\n      );\n      if (mapInitializeValue == null) {\n        set(destination, memberPath, defaultEmptyValue);\n        continue;\n      }\n\n      if (mapInitializeValue instanceof Date) {\n        set(destination, memberPath, new Date(mapInitializeValue));\n        continue;\n      }\n\n      if (Array.isArray(mapInitializeValue)) {\n        const first = mapInitializeValue[0];\n        if (typeof first !== 'object') {\n          set(destination, memberPath, mapInitializeValue.slice());\n          continue;\n        }\n\n        if (isEmpty(first)) {\n          set(destination, memberPath, []);\n          continue;\n        }\n\n        const nestedMapping = getMappingForNestedKey(\n          destinationModel,\n          memberPath as keyof TDestination,\n          first.constructor,\n          mappingStorage\n        );\n        set(\n          destination,\n          memberPath,\n          mapArray(\n            mapInitializeValue,\n            nestedMapping,\n            { skipUnmappedAssertion: options.skipUnmappedAssertion },\n            mappingStorage\n          )\n        );\n        continue;\n      }\n\n      if (\n        (typeof mapInitializeValue === 'object' ||\n          typeof mapInitializeValue === 'function') &&\n        isClass(mapInitializeValue)\n      ) {\n        const nestedMapping = getMappingForDestination(\n          get(destination, null, memberPath).constructor,\n          mapInitializeValue.constructor,\n          mappingStorage\n        ) as Mapping;\n        set(\n          destination,\n          memberPath,\n          map(\n            mapInitializeValue,\n            nestedMapping,\n            { skipUnmappedAssertion: options.skipUnmappedAssertion },\n            mappingStorage\n          )\n        );\n        continue;\n      }\n\n      set(destination, memberPath, mapInitializeValue);\n      continue;\n    }\n\n    set(\n      destination,\n      memberPath,\n      mapMember(\n        transformation.mapFn,\n        sourceObj,\n        sourceMemberPath,\n        destination,\n        mappingStorage,\n        defaultEmptyValue\n      )\n    );\n  }\n\n  if (!isArrayMap) {\n    if (afterMap) {\n      afterMap(sourceObj, destination, { ...mapping } as any);\n    } else if (afterAction) {\n      afterAction(sourceObj, destination, { ...mapping } as any);\n    }\n  }\n\n  if (!skipUnmappedAssertion) {\n    const unmappedKeys = Object.keys(destination).filter(\n      k => !configKeys.includes(k)\n    );\n    if (unmappedKeys.length > 0) {\n      throw new Error(`\nError mapping:\n- Source: ${sourceModel.toString()}\n- Destination: ${destinationModel.toString()}\n\nUnmapped properties:\n-------------------\n${unmappedKeys.join(',\\n')}\n`);\n    }\n  }\n  return destination;\n}\n\nexport function mapArray<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  sourceArray: TSource[],\n  mapping: Mapping<TSource, TDestination>,\n  options: MapOptions<TSource[], TDestination[]>,\n  mappingStorage: MappingStorage\n): TDestination[] {\n  let destination: TDestination[] = [];\n  const { beforeMap, afterMap } = options;\n\n  if (beforeMap) {\n    beforeMap(sourceArray, destination, { ...mapping });\n  }\n\n  for (let i = 0, len = sourceArray.length; i < len; i++) {\n    destination.push(\n      map(\n        sourceArray[i],\n        mapping,\n        { skipUnmappedAssertion: options.skipUnmappedAssertion },\n        mappingStorage,\n        true\n      )\n    );\n  }\n\n  if (afterMap) {\n    afterMap(sourceArray, destination, { ...mapping });\n  }\n\n  return destination;\n}\n","import { Constructible } from '../types';\nimport { storeMetadata } from '../utils';\n\nexport class MetadataExplorer {\n  private static readonly metadataTrackMap = new Map();\n  private static readonly AUTOMAPPER_METADATA_FACTORY =\n    '__NARTC_AUTOMAPPER_METADATA_FACTORY';\n\n  static explore(source: Constructible, destination: Constructible): void {\n    this.exploreInternal(source);\n    this.exploreInternal(destination);\n  }\n\n  private static exploreInternal(model: Constructible): void {\n    if (!model.prototype || this.metadataTrackMap.has(model)) {\n      return;\n    }\n\n    const factory = model[this.AUTOMAPPER_METADATA_FACTORY];\n    if (!factory) {\n      return;\n    }\n\n    const metadata = factory();\n    const metadataEntries: [string, () => any][] = Object.entries(metadata);\n    let i = metadataEntries.length;\n    if (!i) {\n      return;\n    }\n\n    while (i--) {\n      const [key, value] = metadataEntries[i];\n      if (!value) {\n        storeMetadata(model, 'String', key);\n        continue;\n      }\n\n      const meta = value();\n      const metaName = meta.prototype.constructor.name;\n      storeMetadata(model, metaName, key, meta);\n    }\n\n    this.metadataTrackMap.set(model, 1);\n  }\n}\n","import 'reflect-metadata';\nimport { defaultNamingConvention } from './conventions';\nimport {\n  createMapFluentFunction,\n  createMappingObject,\n  getMappingForDestination,\n  getMapProps,\n  map,\n  mapArray,\n} from './core';\nimport { ErrorHandler } from './error-handler';\nimport { MetadataExplorer } from './explorers';\nimport { MappingStorage, ProfileStorage } from './storages';\nimport { instanceStorage } from './storages/instance.storage';\nimport {\n  AutoMapperGlobalSettings,\n  BaseOf,\n  Constructible,\n  CreateMapFluentFunction,\n  CreateMapOptions,\n  Dict,\n  MapOptions,\n  Mapping,\n  MappingProfile,\n  NamingConvention,\n} from './types';\n\nexport class AutoMapper {\n  private readonly _mappingStorage = new MappingStorage();\n  private readonly _profileStorage = new ProfileStorage();\n\n  private defaultGlobalSettings!: [\n    boolean,\n    boolean,\n    Constructible<NamingConvention>,\n    Constructible<NamingConvention>\n  ];\n\n  constructor() {\n    this.setDefault();\n  }\n\n  /**\n   * Provide global naming conventions and useUndefined to the models\n   *\n   * @param {AutoMapperGlobalSettings} settings\n   */\n  withGlobalSettings(settings: AutoMapperGlobalSettings): AutoMapper {\n    const {\n      useUndefined,\n      skipUnmappedAssertion,\n      sourceNamingConvention,\n      destinationNamingConvention,\n      throwError,\n    } = settings;\n\n    this.defaultGlobalSettings[0] = useUndefined ?? false;\n    this.defaultGlobalSettings[1] = skipUnmappedAssertion ?? false;\n\n    if (sourceNamingConvention) {\n      this.defaultGlobalSettings[2] = sourceNamingConvention;\n    }\n\n    if (destinationNamingConvention) {\n      this.defaultGlobalSettings[3] = destinationNamingConvention;\n    }\n\n    if (throwError != null) {\n      ErrorHandler.setShouldThrow(throwError);\n    }\n\n    return this;\n  }\n\n  /**\n   * Add a Profile to this AutoMapper instance\n   * @param {MappingProfile} profile\n   */\n  addProfile(profile: new (mapper: AutoMapper) => MappingProfile): AutoMapper {\n    this._profileStorage.add(this, new profile(this));\n    return this;\n  }\n\n  /**\n   * Create a mapping between a Source and a Destination with an optional Options\n   *\n   * @param {Constructible} source\n   * @param {Constructible} destination\n   * @param {CreateMapOptions} options - Provide inheritance and naming conventions for this Mapping\n   */\n  createMap<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any,\n    TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n    TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n  >(\n    source: Constructible<TSource>,\n    destination: Constructible<TDestination>,\n    options?: CreateMapOptions<\n      TSource,\n      TDestination,\n      TBaseSource,\n      TBaseDestination\n    >\n  ): CreateMapFluentFunction<TSource, TDestination> {\n    MetadataExplorer.explore(source, destination);\n    const mergeOptions: CreateMapOptions<\n      TSource,\n      TDestination,\n      TBaseSource,\n      TBaseDestination\n    > = {\n      useUndefined: this.defaultGlobalSettings[0],\n      sourceMemberNamingConvention: this.defaultGlobalSettings[2],\n      destinationMemberNamingConvention: this.defaultGlobalSettings[3],\n      ...options,\n    };\n    const mapping = createMappingObject(\n      source,\n      destination,\n      mergeOptions,\n      this._mappingStorage\n    );\n    return createMapFluentFunction(mapping, mergeOptions, this._mappingStorage);\n  }\n\n  /**\n   * Map a sourceObj to the Destination with Source model provided.\n   * Usually used to map plain object of Source instead of an instance of Source.\n   *\n   * @example\n   * ```typescript\n   * const user = this.db.findOne(...).toJSON();\n   * Mapper.map(user, UserVm, User);\n   * ```\n   *\n   * @param {object} sourceObj\n   * @param {Constructible} destination\n   * @param {Constructible} source\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  map<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource, TDestination>\n  ): TDestination;\n  /**\n   * Map a sourceObj to the Destination with an optional Options provided.\n   *\n   * @param {object} sourceObj\n   * @param {Constructible} destination\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  map<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource, TDestination>\n  ): TDestination;\n  map<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceObj: TSource, ...args: any[]): TDestination {\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceObj.constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n    return map(sourceObj, mapping, options, this._mappingStorage);\n  }\n\n  /**\n   * Async version of map()\n   */\n  mapAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource, TDestination>\n  ): Promise<TDestination>;\n  /**\n   * Async version of map()\n   */\n  mapAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource, TDestination>\n  ): Promise<TDestination>;\n  mapAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceObj: TSource, ...args: any[]): Promise<TDestination> {\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceObj.constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n    return Promise.resolve().then(() =>\n      map(sourceObj, mapping, options, this._mappingStorage)\n    );\n  }\n\n  /**\n   * Map a sourceArr to an array of Destination with Source model provided.\n   * Usually used to map plain array of Source instead of an instance of Source.\n   *\n   * @example\n   * ```typescript\n   * const user = this.db.findOne(...).toJSON();\n   * Mapper.map(user, UserVm, User);\n   * ```\n   *\n   * @param {Array} sourceArr\n   * @param {Constructible} destination\n   * @param {Constructible} source\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  mapArray<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): TDestination[];\n  /**\n   * Map a sourceArr to an Array of Destination with an optional Options provided.\n   *\n   * @param {Array} sourceArr\n   * @param {Constructible} destination\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  mapArray<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): TDestination[];\n  mapArray<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceArr: TSource[], ...args: any[]): TDestination[] {\n    if (!sourceArr.length) {\n      return [];\n    }\n\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceArr[0].constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n\n    return mapArray(sourceArr, mapping, options, this._mappingStorage);\n  }\n\n  /**\n   * Async version of mapArray()\n   */\n  mapArrayAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): Promise<TDestination[]>;\n  /**\n   * Async version of mapArray()\n   */\n  mapArrayAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): Promise<TDestination[]>;\n  mapArrayAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceArr: TSource[], ...args: any[]): Promise<TDestination[]> {\n    if (!sourceArr.length) {\n      return Promise.resolve().then(() => []);\n    }\n\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceArr[0].constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n\n    return Promise.resolve().then(() =>\n      mapArray(sourceArr, mapping, options, this._mappingStorage)\n    );\n  }\n\n  /**\n   * Retrieve the mapping of a Source and a Destination\n   *\n   * @param {Constructible} source\n   * @param {Constructible} destination\n   */\n  getMapping<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    source: Constructible<TSource>,\n    destination: Constructible<TDestination>\n  ): Mapping<TSource, TDestination> | undefined {\n    return this._mappingStorage.get(source, destination);\n  }\n\n  /**\n   * Dispose of all Mappings and Profiles on the AutoMapper instance\n   */\n  dispose(): void {\n    this.setDefault();\n    this._mappingStorage.dispose();\n    instanceStorage.dispose();\n  }\n\n  /**\n   * Retrieve the current instance of the MappingStorage on the AutoMapper instance\n   */\n  get mappingStorage(): MappingStorage {\n    return this._mappingStorage;\n  }\n\n  /**\n   * Retrieve the current instance of the ProfileStorage on the AutoMapper instance\n   */\n  get profileStorage(): ProfileStorage {\n    return this._profileStorage;\n  }\n\n  private setDefault() {\n    this._profileStorage.initialize(this);\n    this.defaultGlobalSettings = [\n      false,\n      false,\n      defaultNamingConvention,\n      defaultNamingConvention,\n    ];\n  }\n}\n\nexport const Mapper = new AutoMapper();\n","import {\n  Constructible,\n  CreateMapMetadataFunction,\n  Dict,\n  MetadataOptions,\n} from './types';\nimport { storeMetadata } from './utils';\n\nexport const createMapMetadata: CreateMapMetadataFunction = <\n  TModel extends Dict<TModel> = any\n>(\n  model: Constructible<TModel>,\n  metadataOptions: MetadataOptions<TModel>\n) => {\n  const entries = Object.entries(metadataOptions);\n\n  let i = entries.length;\n  if (!i) {\n    return;\n  }\n  while (i--) {\n    const [key, metadata]: [string, any] = entries[i];\n    const metadataName =\n      metadata.prototype?.constructor.name || metadata.constructor.name;\n    storeMetadata(model, metadataName, key, metadata);\n  }\n};\n","import { metadataStorage } from '../storages';\nimport { instanceStorage } from '../storages/instance.storage';\nimport { Constructible, MetadataFunction } from '../types';\nimport { storeMetadata } from '../utils';\n\nexport const AutoMap = (\n  typeFn?: () => Function,\n  depth: number = 0\n): PropertyDecorator => (target, propertyKey) => {\n  if (typeFn) {\n    metadataStorage.addMetadata(target.constructor as Constructible, [\n      [propertyKey, typeFn as MetadataFunction],\n    ]);\n    instanceStorage.set(\n      target.constructor as Constructible,\n      propertyKey,\n      depth\n    );\n  } else {\n    let meta = Reflect.getMetadata('design:type', target, propertyKey);\n    if (meta) {\n      storeMetadata(\n        target.constructor as Constructible,\n        meta.prototype.constructor.name,\n        propertyKey as string\n      );\n    }\n  }\n};\n","import {\n  Dict,\n  MapFromFunction,\n  Resolver,\n  SelectorReturn,\n  ValueSelector,\n} from '../types';\n\nexport function mapFrom<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  from:\n    | ValueSelector<TSource, TDestination, TSelectorReturn>\n    | Resolver<TSource, TDestination, TSelectorReturn>\n): ReturnType<MapFromFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    1, // 1: TransformationType.MapFrom\n    from as ValueSelector<TSource, TDestination, TSelectorReturn>,\n    (source, destination) => {\n      if (isResolver(from)) {\n        return from.resolve(source, destination);\n      }\n\n      return from(source);\n    },\n  ];\n}\n\nfunction isResolver(fn: ValueSelector | Resolver<any>): fn is Resolver<any> {\n  return 'resolve' in fn;\n}\n","import { getMappingForDestination, map, mapArray } from '../core';\nimport {\n  Constructible,\n  Dict,\n  Mapping,\n  MapWithFunction,\n  SelectorReturn,\n  Unpacked,\n  ValueSelector,\n} from '../types';\nimport { isClass, isEmpty } from '../utils';\n\nexport function mapWith<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  withDestination: Constructible<Unpacked<TSelectorReturn>>,\n  withValue: ValueSelector<TSource>,\n  valueModel?: () => Constructible\n): ReturnType<MapWithFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    4, // 4: TransformationType.MapFrom\n    withValue,\n    (source, mappingStorage) => {\n      const sourceValue = withValue(source);\n      if (Array.isArray(sourceValue)) {\n        if (isEmpty(sourceValue[0])) {\n          return [];\n        }\n\n        const mapping = getMappingForDestination(\n          withDestination,\n          valueModel?.() || sourceValue[0].constructor,\n          mappingStorage\n        ) as Mapping;\n        return mapArray(\n          sourceValue,\n          mapping,\n          { skipUnmappedAssertion: true },\n          mappingStorage\n        ) as any;\n      }\n\n      if (isEmpty(sourceValue)) {\n        return null;\n      }\n\n      if (!isClass(sourceValue)) {\n        console.warn(\n          `MapWith was invoked with a primitive. No mapping was executed`\n        );\n        return null;\n      }\n\n      const mapping = getMappingForDestination(\n        withDestination,\n        valueModel?.() || sourceValue.constructor,\n        mappingStorage\n      ) as Mapping;\n      return map(\n        sourceValue,\n        mapping,\n        { skipUnmappedAssertion: true },\n        mappingStorage\n      ) as TSelectorReturn;\n    },\n  ];\n}\n","import {\n  ConditionFunction,\n  ConditionPredicate,\n  Dict,\n  SelectorReturn,\n} from '../types';\nimport { get } from '../utils';\n\nexport function condition<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  predicate: ConditionPredicate<TSource>,\n  defaultValue?: TSelectorReturn\n): ReturnType<ConditionFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    2, // 2: TransformationType.Condition\n    null,\n    (source, internalDefaultValue: undefined | null, ...sourceMemberPaths) => {\n      if (predicate(source)) {\n        return get(source, internalDefaultValue, ...sourceMemberPaths);\n      }\n\n      return defaultValue || internalDefaultValue;\n    },\n  ];\n}\n","import { Dict, FromValueFunction, SelectorReturn } from '../types';\n\nexport function fromValue<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  rawValue: TSelectorReturn\n): ReturnType<FromValueFunction<TSource, TDestination, TSelectorReturn>> {\n  // 3: TransformationType.FromValue\n  return [3, null, () => rawValue];\n}\n","import {\n  Converter,\n  ConvertUsingFunction,\n  Dict,\n  Selector,\n  SelectorReturn,\n} from '../types';\n\nexport function convertUsing<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>,\n  TConvertSource = TSource\n>(\n  converter: Converter<TConvertSource, TSelectorReturn>,\n  value?: Selector<TSource, TConvertSource>\n): ReturnType<ConvertUsingFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    5, // 5: TransformationType.ConvertUsing\n    null,\n    source => {\n      let valueToConvert: TConvertSource;\n      if (value) {\n        valueToConvert = value(source);\n      } else {\n        valueToConvert = (source as unknown) as TConvertSource;\n      }\n      return converter.convert(valueToConvert);\n    },\n  ];\n}\n","import { Dict, NullSubstitutionFunction, SelectorReturn } from '../types';\nimport { get } from '../utils';\n\nexport function nullSubstitution<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  substitution: TSelectorReturn\n): ReturnType<\n  NullSubstitutionFunction<TSource, TDestination, TSelectorReturn>\n> {\n  return [\n    7, // 7: TransformationType.NullSubstitution\n    null,\n    (source, ...sourceMemberPaths) =>\n      get(source, substitution, ...sourceMemberPaths),\n  ];\n}\n","import {\n  ConditionPredicate,\n  Dict,\n  PreConditionFunction,\n  SelectorReturn,\n} from '../types';\n\nexport function preCondition<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  predicate: ConditionPredicate<TSource>,\n  defaultValue?: TSelectorReturn\n): ReturnType<PreConditionFunction<TSource, TDestination, TSelectorReturn>> {\n  return [source => predicate(source), defaultValue];\n}\n","import { IgnoreFunction } from '../types';\n\nexport function ignore(): ReturnType<IgnoreFunction> {\n  // 0: TransformationType.Ignore\n  return [0, null, () => {}];\n}\n","import {\n  DeferFunction,\n  Dict,\n  MapDeferFunction,\n  SelectorReturn,\n} from '../types';\n\nexport function mapDefer<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  defer: DeferFunction<TSource, TDestination, TSelectorReturn>\n): ReturnType<MapDeferFunction<TSource, TDestination, TSelectorReturn>> {\n  // 8: TransformationType.MapDefer\n  return [8, null, defer];\n}\n","import { MappingProfile } from './types';\n\nexport abstract class ProfileBase implements MappingProfile {\n  profileName: string;\n\n  protected constructor() {\n    this.profileName = this.constructor.name;\n  }\n}\n"],"names":["CamelCaseNamingConvention","transformPropertyName","sourceNameParts","result","i","len","length","charAt","toLowerCase","toUpperCase","substr","SnakeCaseNamingConvention","sourcePropNameParts","map","p","join","separatorCharacter","PascalCaseNamingConvention","defaultNamingConvention","ErrorHandler","setShouldThrow","shouldThrow","handleError","errorMessage","Error","console","warn","NestStorage","storage","WeakMap","set","key","nestedKey","value","setInternal","get","getInternal","has","hasInternal","WeakMapNestedStorage","dispose","MapNestedStorage","Map","MappingStorage","MetadataStorage","getMetadata","model","metadataMapList","_metadataMap","proto","Object","getPrototypeOf","some","metaKey","push","getMetadataForKey","find","addMetadata","metadata","existingMetadata","existingProtoMetadata","name","existingMeta","existKey","metadataStorage","ProfileStorage","profiles","initialize","mapper","add","profile","profileName","InstanceStorage","recursiveCounts","getDepthAndCount","parent","member","getCount","setCount","count","resetCount","resetAllCount","clear","instanceStorage","storeMetadata","metaName","metaValue","Date","isEmpty","Array","isArray","keys","isClass","fn","typeOfFn","constructorFnString","constructor","toString","test","includes","isThisMemberMap","mapFn","types","type","object","defaultVal","_getInternal","path","_path","split","filter","Boolean","_val","reduce","obj","paths","val","getSourcePropertyKey","sourceNamingConvention","destinationNamingConvention","splitPath","destNamingConvention","srcNamingConvention","keyParts","splittingExpression","getMemberPath","fnString","cleanseAssertionOperators","substring","indexOf","matchRegex","es5Match","match","parsedName","replace","mapInitialize","source","instantiate","defaultValue","instance","assign","meta","metaResult","undefined","prototype","v","depth","initializeMappingProps","mapping","srcModel","destModel","destination","sourceProtoConstructor","sourceProto","destinationPaths","getPathRecursive","useUndefined","sourcePath","dottedSourcePaths","hasOwnProperty","convention","first","sourceMemberPath","concat","seal","transformation","preCond","node","prefix","prev","getOwnPropertyNames","child","queue","childNode","childPaths","childPath","createMappingObject","options","mappingStorage","sourceMemberNamingConvention","destinationMemberNamingConvention","getMappingForDestination","isInherit","inheritBaseMapping","baseMapping","props","baseProps","basePropKey","baseProp","propFromBase","existProp","pKey","initializeReverseMappingProps","reversedProps","destPath","propPath","createReverseMappingObject","sourceConvention","destinationConvention","bases","reversedMapping","slice","reverse","reversedBaseMapping","createMapForMember","selector","fluentFunction","mapMemberFn","memberPath","mappingProperty","propName","createReverseMapFluentFunction","reversedMapFluentFunction","forPath","functions","beforeMap","action","afterMap","createMapFluentFunction","includeBase","baseSource","baseDestination","forMember","reverseMap","getMappingForNestedKey","destinationConstructor","destinationMemberKey","sourceConstructor","keyMetadata","getMapProps","args","skipUnmappedAssertion","defaultOptions","temp","mapMember","sourceObj","memberMapFunction","isArrayMap","sourceModel","destinationModel","actions","defaultEmptyValue","beforeAction","afterAction","configKeys","mapInitializeValue","nestedMapping","mapArray","unmappedKeys","k","sourceArray","MetadataExplorer","explore","exploreInternal","metadataTrackMap","factory","AUTOMAPPER_METADATA_FACTORY","metadataEntries","entries","AutoMapper","setDefault","withGlobalSettings","settings","throwError","defaultGlobalSettings","addProfile","_profileStorage","createMap","mergeOptions","_mappingStorage","mapAsync","Promise","resolve","then","sourceArr","mapArrayAsync","getMapping","Mapper","createMapMetadata","metadataOptions","metadataName","AutoMap","typeFn","target","propertyKey","Reflect","mapFrom","from","isResolver","mapWith","withDestination","withValue","valueModel","sourceValue","condition","predicate","internalDefaultValue","sourceMemberPaths","fromValue","rawValue","convertUsing","converter","valueToConvert","convert","nullSubstitution","substitution","preCondition","ignore","mapDefer","defer","ProfileBase"],"mappings":"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"}