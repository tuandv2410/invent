{"version":3,"file":"automapper.cjs.production.min.js","sources":["../src/conventions/camel-case-naming-convention.ts","../src/conventions/snake-case-naming-convention.ts","../src/conventions/pascal-case-naming-convention.ts","../src/conventions/index.ts","../src/error-handler.ts","../src/storages/base-storage.ts","../src/storages/mapping.storage.ts","../src/storages/metadata.storage.ts","../src/storages/profile.storage.ts","../src/storages/instance.storage.ts","../src/utils/storeMetadata.ts","../src/utils/isEmpty.ts","../src/utils/isClass.ts","../src/utils/isThisMemberMap.ts","../src/utils/get.ts","../src/utils/getSourcePropertyKey.ts","../src/utils/getMemberPath.ts","../src/member-functions/map-initialize.ts","../src/core/instantiate.ts","../src/core/get-mapping-for-destination.ts","../src/core/inherit-base-mapping.ts","../src/core/initialize-reverse-mapping-props.ts","../src/core/create-map-for-member.ts","../src/core/get-mapping-for-nested-key.ts","../src/core/get-map-props.ts","../src/core/map.ts","../src/explorers/metadata.explorer.ts","../src/automapper.ts","../src/core/create-map-fluent-function.ts","../src/core/create-reverse-map-fluent-function.ts","../src/core/create-reverse-mapping-object.ts","../src/core/create-mapping-object.ts","../src/core/initialize-mapping-props.ts","../src/decorators/automap.decorator.ts","../src/profile-base.ts","../src/member-functions/condition.ts","../src/member-functions/convert-using.ts","../src/create-map-metadata.ts","../src/member-functions/from-value.ts","../src/member-functions/ignore.ts","../src/member-functions/map-defer.ts","../src/member-functions/map-from.ts","../src/member-functions/map-with.ts","../src/member-functions/null-substitution.ts","../src/member-functions/pre-condition.ts"],"sourcesContent":["import { NamingConvention } from '../types';\n\n/**\n * camelCase naming convention\n */\nexport class CamelCaseNamingConvention implements NamingConvention {\n  separatorCharacter = '';\n  splittingExpression: RegExp = /(^[a-z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n\n  public transformPropertyName(sourceNameParts: string[]): string {\n    let result = '';\n\n    for (let i = 0, len = sourceNameParts.length; i < len; i++) {\n      if (i === 0) {\n        result += sourceNameParts[i].charAt(0).toLowerCase();\n      } else {\n        result += sourceNameParts[i].charAt(0).toUpperCase();\n      }\n\n      result += sourceNameParts[i].substr(1);\n    }\n\n    return result;\n  }\n}\n","import { NamingConvention } from '../types';\n\nexport class SnakeCaseNamingConvention implements NamingConvention {\n  separatorCharacter: string = '_';\n  splittingExpression: RegExp = /_/;\n\n  public transformPropertyName(sourcePropNameParts: string[]): string {\n    const len = sourcePropNameParts.length;\n\n    if (len <= 1) {\n      return sourcePropNameParts[0].toLowerCase() || '';\n    }\n\n    return sourcePropNameParts\n      .map(p => p.toLowerCase())\n      .join(this.separatorCharacter);\n  }\n}\n","import { NamingConvention } from '../types';\n\n/**\n * PascalCase naming convention\n */\nexport class PascalCaseNamingConvention implements NamingConvention {\n  separatorCharacter = '';\n  splittingExpression: RegExp = /(^[A-Z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n\n  public transformPropertyName(sourceNameParts: string[]): string {\n    let result = '';\n\n    for (let i = 0, len = sourceNameParts.length; i < len; i++) {\n      result +=\n        sourceNameParts[i].charAt(0).toUpperCase() +\n        sourceNameParts[i].substr(1);\n    }\n\n    return result;\n  }\n}\n","import { CamelCaseNamingConvention } from './camel-case-naming-convention';\n\nexport * from './snake-case-naming-convention';\nexport * from './camel-case-naming-convention';\nexport * from './pascal-case-naming-convention';\nexport const defaultNamingConvention = CamelCaseNamingConvention;\n","export class ErrorHandler {\n  private static shouldThrow = true;\n\n  static setShouldThrow(shouldThrow: boolean): void {\n    this.shouldThrow = shouldThrow;\n  }\n\n  static handleError(errorMessage: string): void {\n    if (this.shouldThrow) {\n      throw new Error(errorMessage);\n    } else {\n      console.warn(errorMessage);\n      return;\n    }\n  }\n}\n","export abstract class NestStorage<\n  TKey extends object = any,\n  TValue = unknown,\n  TNestedMap extends Map<any, TValue> | WeakMap<TKey, TValue> = any\n> {\n  protected storage: WeakMap<TKey, TNestedMap>;\n\n  protected constructor() {\n    this.storage = new WeakMap<TKey, TNestedMap>();\n  }\n\n  set(key: TKey, nestedKey: any, value: TValue): void {\n    this.setInternal(this.storage, key, nestedKey, value);\n  }\n\n  get(key: TKey, nestedKey: any): TValue | undefined {\n    return this.getInternal(this.storage, key, nestedKey);\n  }\n\n  has(key: TKey, nestedKey: any): boolean {\n    return this.hasInternal(this.storage, key, nestedKey);\n  }\n\n  protected getInternal<\n    TKey extends object = any,\n    TValue = unknown,\n    TNestedMap extends Map<any, TValue> | WeakMap<TKey, TValue> = any\n  >(\n    storage: WeakMap<TKey, TNestedMap>,\n    key: TKey,\n    nestedKey: any\n  ): TValue | undefined {\n    return storage.get(key)?.get(nestedKey);\n  }\n\n  protected hasInternal<\n    TKey extends object = any,\n    TValue = unknown,\n    TNestedMap extends Map<any, TValue> | WeakMap<TKey, TValue> = any\n  >(storage: WeakMap<TKey, TNestedMap>, key: TKey, nestedKey: any): boolean {\n    return storage.get(key)?.has(nestedKey) || false;\n  }\n\n  protected abstract setInternal<TKey extends object = any, TValue = unknown>(\n    storage: WeakMap<TKey, any>,\n    key: TKey,\n    nestedKey: any,\n    value: TValue\n  ): void;\n}\n\nexport abstract class WeakMapNestedStorage<\n  TKey extends object = any,\n  TValue = unknown\n> extends NestStorage<TKey, TValue, WeakMap<TKey, TValue>> {\n  protected constructor() {\n    super();\n  }\n\n  dispose(): void {\n    this.storage = new WeakMap<TKey, WeakMap<TKey, TValue>>();\n  }\n\n  protected setInternal<TKey extends object = any, TValue = unknown>(\n    storage: WeakMap<TKey, WeakMap<TKey, TValue>>,\n    key: TKey,\n    nestedKey: TKey,\n    value: TValue\n  ) {\n    if (!storage.has(key)) {\n      storage.set(key, new WeakMap<TKey, TValue>().set(nestedKey, value));\n      return;\n    }\n\n    if (!this.hasInternal(storage, key, nestedKey)) {\n      storage.get(key)!.set(nestedKey, value);\n    }\n  }\n}\n\nexport abstract class MapNestedStorage<\n  TKey extends object = any,\n  TValue = unknown\n> extends NestStorage<TKey, TValue, Map<any, TValue>> {\n  protected constructor() {\n    super();\n  }\n\n  protected setInternal<TKey extends object = any, TValue = unknown>(\n    storage: WeakMap<TKey, Map<any, TValue>>,\n    key: TKey,\n    nestedKey: unknown,\n    value: TValue\n  ) {\n    if (!storage.has(key)) {\n      storage.set(key, new Map<any, TValue>().set(nestedKey, value));\n      return;\n    }\n\n    if (!this.hasInternal(storage, key, nestedKey)) {\n      storage.get(key)!.set(nestedKey, value);\n    }\n  }\n}\n","import { Constructible, Mapping } from '../types';\nimport { WeakMapNestedStorage } from './base-storage';\n\n/**\n * Internal MappingStorage class\n * @private\n */\nexport class MappingStorage extends WeakMapNestedStorage<\n  Constructible,\n  Mapping\n> {\n  constructor() {\n    super();\n  }\n}\n","import { Constructible, Dict, MetadataMap, MetadataMapList } from '../types';\n\n/**\n * Internal MetadataStorage class\n *\n * @private\n */\nclass MetadataStorage {\n  private _metadataMap = new Map<Constructible, MetadataMapList>();\n\n  getMetadata<TModel extends Dict<TModel> = any>(\n    model: Constructible<TModel>\n  ): MetadataMapList<TModel> {\n    const metadataMapList = this._metadataMap.get(model) as MetadataMapList<\n      TModel\n    >;\n    let i = metadataMapList?.length || 0;\n\n    if (!i) {\n      const proto = Object.getPrototypeOf(model);\n      return proto ? this.getMetadata(proto) : metadataMapList;\n    }\n\n    const result: MetadataMapList<TModel> = [];\n    while (i--) {\n      const [key] = metadataMapList[i];\n      if (result.some(([metaKey]) => metaKey === key)) {\n        continue;\n      }\n      result.push(metadataMapList[i]);\n    }\n    return result;\n  }\n\n  getMetadataForKey<TModel extends Dict<TModel> = any>(\n    model: Constructible<TModel>,\n    key: keyof TModel\n  ): MetadataMap<TModel> | undefined {\n    return this.getMetadata(model).find(([metaKey]) => metaKey === key);\n  }\n\n  addMetadata<TModel extends Dict<TModel> = any>(\n    model: Constructible<TModel>,\n    metadata: MetadataMapList<TModel>\n  ) {\n    const existingMetadata = this._metadataMap.get(model) || [];\n    const proto = Object.getPrototypeOf(model);\n    const existingProtoMetadata =\n      proto && !!proto.name ? this._metadataMap.get(proto) || [] : [];\n\n    const existingMeta = [...existingProtoMetadata, ...existingMetadata];\n\n    for (let [existKey] of existingMeta) {\n      const [key] = metadata[0];\n      if (key === existKey) {\n        return;\n      }\n    }\n\n    this._metadataMap.set(model, [...existingMeta, ...metadata]);\n  }\n}\n\nexport const metadataStorage = new MetadataStorage();\n","import { AutoMapper } from '../automapper';\nimport { ErrorHandler } from '../error-handler';\nimport { MappingProfile } from '../types';\n\n/**\n * Internal ProfileStorage class\n *\n * @private\n */\nexport class ProfileStorage {\n  private profiles: WeakMap<AutoMapper, MappingProfile[]>;\n\n  constructor() {\n    this.profiles = new WeakMap<AutoMapper, MappingProfile[]>();\n  }\n\n  /**\n   * Initialize a Mapper instance with an empty profiles array\n   *\n   * @param {AutoMapper} mapper - Mapper instance to initialize\n   */\n  initialize(mapper: AutoMapper): void {\n    this.profiles.set(mapper, []);\n  }\n\n  /**\n   * Add a MappingProfile to a Mapper instance\n   *\n   * @param {AutoMapper} mapper - Mapper instance to initialize\n   * @param {MappingProfile} profile - MappingProfile to add to the mapper instance\n   */\n  add(mapper: AutoMapper, profile: MappingProfile): void {\n    const profiles = this.profiles.get(mapper) as MappingProfile[];\n    if (profiles.some(p => p.profileName === profile.profileName)) {\n      ErrorHandler.handleError(\n        `${profile.profileName} already exists on this mapper instance`\n      );\n    }\n\n    profiles.push(profile);\n  }\n}\n","/**\n * Internal InstanceStorage class\n * @private\n */\nimport { Constructible } from '../types';\nimport { MapNestedStorage } from './base-storage';\n\nclass InstanceStorage extends MapNestedStorage<Constructible, number> {\n  private recursiveCounts: WeakMap<Constructible, Map<string, number>>;\n\n  constructor() {\n    super();\n    this.recursiveCounts = new WeakMap<Constructible, Map<string, number>>();\n  }\n\n  getDepthAndCount(\n    parent: Constructible,\n    member: string\n  ): [number | undefined, number | undefined] {\n    return [this.get(parent, member), this.getCount(parent, member)];\n  }\n\n  setCount(parent: Constructible, member: string, count: number) {\n    if (this.recursiveCounts.has(parent)) {\n      this.recursiveCounts.get(parent)!.set(member, count);\n    } else {\n      this.setInternal(this.recursiveCounts, parent, member, count);\n    }\n  }\n\n  resetCount(parent: Constructible, member: string) {\n    this.recursiveCounts.get(parent)?.set(member, 0);\n  }\n\n  resetAllCount(model: Constructible) {\n    this.recursiveCounts.get(model)?.clear();\n  }\n\n  private getCount(parent: Constructible, member: string): number | undefined {\n    return this.getInternal(this.recursiveCounts, parent, member);\n  }\n\n  dispose() {\n    this.recursiveCounts = new WeakMap<Constructible, Map<string, number>>();\n  }\n}\n\nexport const instanceStorage = new InstanceStorage();\n","import { metadataStorage } from '../storages';\nimport { Constructible, Dict } from '../types';\n\nexport function storeMetadata<TModel extends Dict<TModel> = any>(\n  model: Constructible<TModel>,\n  metaName: string,\n  metaKey: string,\n  metaValue?: any\n) {\n  switch (metaName) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n      metadataStorage.addMetadata(model, [[metaKey, () => false]]);\n      break;\n    case 'Date':\n      metadataStorage.addMetadata(model, [[metaKey, () => Date]]);\n      break;\n    case 'Array':\n      metadataStorage.addMetadata(model, [[metaKey, () => []]]);\n      break;\n    default:\n      metadataStorage.addMetadata(model, [[metaKey, () => metaValue]]);\n      break;\n  }\n}\n","export function isEmpty(value: any): boolean {\n  if (Array.isArray(value)) {\n    return !value.length;\n  }\n\n  return !value || !Object.keys(value).length;\n}\n","export function isClass(fn: Function | Object): boolean {\n  const typeOfFn = typeof fn;\n  const constructorFnString = fn.constructor?.toString();\n  return (\n    (typeOfFn === 'object' || typeOfFn === 'function') &&\n    fn.constructor &&\n    (/^\\s*function/.test(constructorFnString) ||\n      /^\\s*class/.test(constructorFnString)) &&\n    constructorFnString.includes(fn.constructor.name)\n  );\n}\n","import {\n  MemberMapFunction,\n  MemberMapFunctionId,\n  TransformationType,\n} from '../types';\n\n// TODO(chau): use Variadic Tuple Type when upgrade to TypeScript 4.1\nexport function isThisMemberMap<TMemberMap extends MemberMapFunction>(\n  mapFn: ReturnType<MemberMapFunction>,\n  type: TransformationType\n): mapFn is ReturnType<TMemberMap>;\nexport function isThisMemberMap<\n  TMemberMapA extends MemberMapFunction,\n  TMemberMapB extends MemberMapFunction\n>(\n  mapFn: ReturnType<MemberMapFunction>,\n  typeA: TransformationType,\n  typeB: TransformationType\n): mapFn is ReturnType<TMemberMapA | TMemberMapB>;\nexport function isThisMemberMap<\n  TMemberMapA extends MemberMapFunction,\n  TMemberMapB extends MemberMapFunction,\n  TMemberMapC extends MemberMapFunction\n>(\n  mapFn: ReturnType<MemberMapFunction>,\n  typeA: TransformationType,\n  typeB: TransformationType,\n  typeC: TransformationType\n): mapFn is ReturnType<TMemberMapA | TMemberMapB | TMemberMapC>;\nexport function isThisMemberMap(\n  mapFn: ReturnType<MemberMapFunction>,\n  ...types: TransformationType[]\n) {\n  return types.some(type => mapFn[MemberMapFunctionId.type] === type);\n}\n","export function get<T>(\n  object: T,\n  defaultVal: unknown,\n  ...paths: string[]\n): any {\n  function _getInternal(object: T, path: string) {\n    const _path = path.split('.').filter(Boolean);\n    const _val = _path.reduce((obj: any, key) => obj && obj[key], object);\n    return _val != null ? _val : defaultVal;\n  }\n\n  let val = _getInternal(object, paths[0]);\n  for (let i = 1, len = paths.length; i < len; i++) {\n    if (val != null) {\n      val = _getInternal(val, paths[i]);\n      continue;\n    }\n    val = _getInternal(object, paths[i]);\n  }\n\n  return val;\n}\n","import { Constructible, NamingConvention } from '../types';\n\nexport function getSourcePropertyKey(\n  [sourceNamingConvention, destinationNamingConvention]: [\n    Constructible<NamingConvention>,\n    Constructible<NamingConvention>\n  ],\n  path: string\n): string {\n  const splitPath = path.split('.');\n  if (splitPath.length > 1) {\n    return splitPath\n      .map(key =>\n        getSourcePropertyKey(\n          [sourceNamingConvention, destinationNamingConvention],\n          key\n        )\n      )\n      .join('.');\n  }\n\n  const destNamingConvention = new destinationNamingConvention();\n  const srcNamingConvention = new sourceNamingConvention();\n  const keyParts = path\n    .split(destNamingConvention.splittingExpression)\n    .filter(Boolean);\n  return !keyParts.length\n    ? path\n    : srcNamingConvention.transformPropertyName(keyParts);\n}\n","import { Selector } from '../types';\n\n/**\n * https://github.com/IRCraziestTaxi/ts-simple-nameof\n * This implementation is copied from the linked library.\n *\n * Old implementation:\n *\n if (/^[^{]+?=>/gm.test(fnString)) {\n    let value: string[];\n    const _parts = fnString\n      .replace(/(?:\\s|;|{|}|\\(|\\)|)+/gm, '')\n      .split(/=>(.+)/);\n    const _returnPart = _parts[1];\n    const _returnMatches = _returnPart.match(/return/g);\n\n    if (_returnMatches?.length && _returnMatches.length > 1) {\n      value = [_parts[0]].concat(\n        ..._returnPart.split(/return(.+)/).filter(Boolean)\n      );\n    } else {\n      value = _parts;\n    }\n\n    return getPathFromSelector(value);\n  }\n  return getPathFromSelector(\n    fnString.replace(/(?:\\s|function|;|{|}|\\(|\\)|)+/gm, '').split(/return(.+)/)\n  );\n\n  function getPathFromSelector(fnParts: string[]): string {\n  const [, ...parts] = fnParts\n    .join('')\n    .split(new RegExp(`${fnParts[0]}\\\\.{1}`, 'g'))\n    .filter(Boolean);\n\n  if (parts.length === 1) {\n    return parts.pop() as string;\n  }\n\n  return '';\n}\n */\nexport function getMemberPath(fn: Selector): string {\n  const fnString = fn.toString();\n\n  // ES6 prop selector:\n  // \"x => x.prop\"\n  if (fnString.includes('=>')) {\n    return cleanseAssertionOperators(\n      fnString.substring(fnString.indexOf('.') + 1)\n    );\n  }\n\n  // ES5 prop selector:\n  // \"function (x) { return x.prop; }\"\n  // webpack production build excludes the spaces and optional trailing semicolon:\n  //   \"function(x){return x.prop}\"\n  // FYI - during local dev testing i observed carriage returns after the curly brackets as well\n  // Note by maintainer: See https://github.com/IRCraziestTaxi/ts-simple-nameof/pull/13#issuecomment-567171802 for\n  // explanation of this regex.\n  const matchRegex = /function\\s*\\(\\w+\\)\\s*{[\\r\\n\\s]*return\\s+\\w+\\.((\\w+\\.)*(\\w+))/i;\n\n  const es5Match = fnString.match(matchRegex);\n\n  if (es5Match) {\n    return es5Match[1]!;\n  }\n\n  return '';\n}\n\nfunction cleanseAssertionOperators(parsedName: string): string {\n  return parsedName.replace(/[?!]/g, '').replace(/(?:\\s|;|{|}|\\(|\\)|)+/gm, '');\n}\n","import {\n  Dict,\n  MapInitializeFunction,\n  SelectorReturn,\n  TransformationType,\n} from '../types';\nimport { get } from '../utils';\n\nexport function mapInitialize<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  defaultVal: undefined | null,\n  ...paths: string[]\n): ReturnType<MapInitializeFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    TransformationType.MapInitialize,\n    null,\n    source => get(source, defaultVal, ...paths),\n  ];\n}\n","import { instanceStorage, metadataStorage } from '../storages';\nimport { Constructible, Dict } from '../types';\nimport { isEmpty } from '../utils';\n\nexport function instantiate<TModel extends Dict<TModel>>(\n  model: Constructible<TModel>,\n  defaultValue?: TModel\n): TModel {\n  const metadata = metadataStorage.getMetadata(model);\n\n  const instance = (defaultValue\n    ? Object.assign(new model(), defaultValue)\n    : new model()) as any;\n  if (isEmpty(metadata) || !metadata) {\n    return instance;\n  }\n\n  let i = metadata.length;\n  while (i--) {\n    const [key, meta] = metadata[i];\n    const value = instance[key];\n    const metaResult = meta();\n    if (!metaResult) {\n      instance[key] = value != null ? value : undefined;\n      continue;\n    }\n\n    if (Array.isArray(metaResult)) {\n      instance[key] = value != null ? value : metaResult;\n      continue;\n    }\n\n    if (\n      metaResult.prototype.constructor.name === 'Date' ||\n      metaResult.prototype.constructor.name === 'Moment'\n    ) {\n      instance[key] = value != null ? new metaResult(value) : new metaResult();\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      instance[key] = value.map(v => instantiate(metaResult, v));\n      continue;\n    }\n\n    if (value == null && defaultValue != null) {\n      instance[key] = value;\n      continue;\n    }\n\n    if (value != null) {\n      instance[key] = instantiate(metaResult, value);\n      continue;\n    }\n\n    const [depth, count = 0] = instanceStorage.getDepthAndCount(model, key);\n\n    if (depth === 0) {\n      instance[key] = new metaResult();\n      continue;\n    }\n\n    if (depth === count) {\n      instanceStorage.resetCount(model, key);\n      instance[key] = new metaResult();\n      continue;\n    }\n\n    instanceStorage.setCount(model, key, count != null ? count + 1 : 1);\n    instance[key] = instantiate(metaResult, value);\n  }\n\n  instanceStorage.resetAllCount(model);\n  return instance;\n}\n","import { MappingStorage } from '../storages';\nimport { Constructible, Dict, Mapping } from '../types';\n\nexport function getMappingForDestination<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  destination: Constructible<TDestination>,\n  source: Constructible<TSource>,\n  mappingStorage: MappingStorage,\n  isInherit: boolean = false\n): Mapping<TSource, TDestination> | undefined | never {\n  const mapping = mappingStorage.get(source, destination);\n\n  if (!mapping && !isInherit) {\n    throw new Error(\n      `Mapping not found for source ${source.toString()} and destination ${destination.toString()}`\n    );\n  }\n\n  return mapping as Mapping<TSource, TDestination>;\n}\n","import {\n  BaseOf,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MappingProperty,\n} from '../types';\n\nexport function inheritBaseMapping<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>,\n  baseMapping: Mapping<TBaseSource, TBaseDestination>\n) {\n  const props = mapping[MappingClassId.props];\n  const baseProps = baseMapping[MappingClassId.props];\n  for (let i = 0, len = baseProps.length; i < len; i++) {\n    const [basePropKey, baseProp] = baseProps[i];\n    const propFromBase = Object.seal({ ...baseProp }) as MappingProperty;\n    const existProp = props.find(([pKey]) => pKey === basePropKey);\n    if (existProp) {\n      existProp[0] = basePropKey;\n      existProp[1] = propFromBase;\n    } else {\n      props.push([basePropKey, propFromBase]);\n    }\n  }\n  mapping[MappingClassId.bases] = [\n    baseMapping[MappingClassId.models][0],\n    baseMapping[MappingClassId.models][1],\n  ];\n}\n","import { mapInitialize } from '../member-functions/map-initialize';\nimport {\n  BaseOf,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MappingProperty,\n  MemberMapFunctionId,\n  Selector,\n} from '../types';\nimport { getMemberPath } from '../utils';\nimport { instantiate } from './instantiate';\n\nexport function initializeReverseMappingProps<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>\n): Array<\n  [\n    string,\n    MappingProperty<TDestination, TSource, ReturnType<Selector<TSource>>>\n  ]\n> {\n  const model = instantiate(mapping[MappingClassId.models][0]);\n  const proto = Object.getPrototypeOf(model);\n  const reversedProps: Array<[\n    string,\n    MappingProperty<TDestination, TSource, ReturnType<Selector<TSource>>>\n  ]> = [];\n\n  const props = mapping[MappingClassId.props];\n  let i = props.length;\n  while (i--) {\n    const { paths, transformation } = props[i][1];\n    const [destPath, sourcePath] = paths;\n\n    /**\n     * 1: TransformationType.MapFrom\n     * 4: TransformationType.MapWith\n     */\n    if (!sourcePath && transformation.type !== 1 && transformation.type !== 4) {\n      continue;\n    }\n\n    let path = '';\n    if (sourcePath) {\n      path = sourcePath;\n    } else {\n      path = getMemberPath(\n        transformation.mapFn[MemberMapFunctionId.fn] as Selector\n      );\n    }\n\n    if (\n      (!model.hasOwnProperty(path) && !proto.hasOwnProperty(path)) ||\n      reversedProps.some(([propPath]) => propPath === path)\n    ) {\n      continue;\n    }\n\n    reversedProps.push([\n      path,\n      Object.seal({\n        paths: [path, destPath],\n        transformation: {\n          type: 6, // 6 is TransformationType.MapInitialize.\n          preCond: undefined,\n          mapFn: mapInitialize(\n            mapping[MappingClassId.conventions][0] ? undefined : null,\n            destPath\n          ),\n        },\n      }),\n    ]);\n  }\n\n  return reversedProps;\n}\n","import {\n  Dict,\n  MapFromFunction,\n  Mapping,\n  MappingClassId,\n  MappingProperty,\n  MapWithFunction,\n  MemberMapFunction,\n  MemberMapFunctionId,\n  PreConditionFunction,\n  Selector,\n} from '../types';\nimport { getMemberPath, isThisMemberMap } from '../utils';\n\nexport function createMapForMember<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelector extends Selector<TDestination> = Selector<TDestination>,\n  TReturnType = any\n>(\n  mapping: Mapping<TSource, TDestination>,\n  selector: TSelector,\n  [preCond, mapMemberFn]: [\n    (\n      | ReturnType<PreConditionFunction<TSource, TDestination>>\n      | ReturnType<MemberMapFunction<TSource, TDestination>>\n    ),\n    ReturnType<MemberMapFunction<TSource, TDestination>>?\n  ],\n  fluentFunction: TReturnType\n): TReturnType {\n  const memberPath = getMemberPath(selector);\n\n  if (mapMemberFn == null) {\n    mapMemberFn = preCond as ReturnType<\n      MemberMapFunction<TSource, TDestination>\n    >;\n    preCond = undefined;\n  }\n\n  let sourcePath: string = '';\n  // 1: TransformationType.MapFrom\n  // 4: TransformationType.MapWith\n  if (isThisMemberMap<MapFromFunction, MapWithFunction>(mapMemberFn, 1, 4)) {\n    sourcePath = getMemberPath(mapMemberFn[MemberMapFunctionId.misc]);\n  }\n\n  const paths: [string, string?] = !!sourcePath\n    ? [memberPath, sourcePath]\n    : [memberPath];\n\n  const mappingProperty: MappingProperty<\n    TSource,\n    TDestination,\n    ReturnType<TSelector>\n  > = Object.seal({\n    paths,\n    transformation: {\n      mapFn: mapMemberFn,\n      type: mapMemberFn[MemberMapFunctionId.type],\n      preCond: preCond as ReturnType<\n        PreConditionFunction<TSource, TDestination>\n      >,\n    },\n  });\n\n  const existProp = mapping[MappingClassId.props].find(\n    ([propName]) => propName === memberPath\n  );\n  if (existProp != null) {\n    existProp[1] = mappingProperty;\n    return fluentFunction;\n  }\n\n  mapping[MappingClassId.props].push([memberPath, mappingProperty]);\n  return fluentFunction;\n}\n","import { MappingStorage, metadataStorage } from '../storages';\nimport { Constructible, Dict, Mapping, MetadataMap } from '../types';\n\nexport function getMappingForNestedKey<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TDestinationKey extends keyof TDestination = any\n>(\n  destinationConstructor: Constructible<TDestination>,\n  destinationMemberKey: TDestinationKey,\n  sourceConstructor: Constructible<TSource>,\n  mappingStorage: MappingStorage\n): Mapping<TSource, TDestination[TDestinationKey]> {\n  const keyMetadata = metadataStorage.getMetadataForKey(\n    destinationConstructor,\n    destinationMemberKey\n  ) as MetadataMap<TDestination>;\n\n  const meta = keyMetadata[1]();\n  if (!meta || Array.isArray(meta)) {\n    throw new Error(\n      `Metadata for ${destinationMemberKey} is a primitive or Array. Consider manual map this property`\n    );\n  }\n\n  const mapping = mappingStorage.get(sourceConstructor, meta);\n  if (!mapping) {\n    throw new Error(\n      `Mapping for ${destinationMemberKey} cannot be found. Consider manual map this property with MapWith`\n    );\n  }\n\n  return mapping;\n}\n","import { Constructible, Dict, MapOptions } from '../types';\nimport { isClass } from '../utils';\n\nexport function getMapProps<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  args: any[],\n  skipUnmappedAssertion: boolean\n): [\n  Constructible<TDestination>,\n  MapOptions<TSource, TDestination>,\n  Constructible<TSource>?\n] {\n  const destination: Constructible<TDestination> = args[0];\n  const defaultOptions = {\n    skipUnmappedAssertion,\n    beforeMap: undefined,\n    afterMap: undefined,\n  };\n\n  if (args.length === 1) {\n    return [destination, defaultOptions];\n  }\n\n  if (args.length === 3) {\n    return [destination, { ...defaultOptions, ...args[2] }, args[1]];\n  }\n\n  let temp = args[1];\n\n  if (\n    (typeof temp === 'function' || isClass(temp)) &&\n    !temp['beforeMap'] &&\n    !temp['afterMap']\n  ) {\n    return [destination, defaultOptions, temp];\n  }\n\n  return [destination, { ...defaultOptions, ...temp }];\n}\n","import set from 'lodash.set';\nimport { MappingStorage } from '../storages';\nimport {\n  ConditionFunction,\n  ConvertUsingFunction,\n  Dict,\n  FromValueFunction,\n  IgnoreFunction,\n  MapFromFunction,\n  MapInitializeFunction,\n  MapOptions,\n  Mapping,\n  MapWithFunction,\n  MemberMapFunction,\n  MemberMapFunctionId,\n  NullSubstitutionFunction,\n} from '../types';\nimport {\n  get,\n  getSourcePropertyKey,\n  isClass,\n  isEmpty,\n  isThisMemberMap,\n} from '../utils';\nimport { getMappingForDestination } from './get-mapping-for-destination';\nimport { getMappingForNestedKey } from './get-mapping-for-nested-key';\nimport { instantiate } from './instantiate';\n\nfunction mapMember<TSource, TDestination>(\n  mapFn: ReturnType<MemberMapFunction<TSource, TDestination>>,\n  sourceObj: TSource,\n  sourceMemberPath: string,\n  destination: TDestination,\n  mappingStorage: MappingStorage,\n  defaultValue: undefined | null\n) {\n  let value: unknown;\n  /**\n   * 0: TransformationType.Ignore\n   * 1: TransformationType.MapFrom\n   * 2: TransformationType.Condition\n   * 3: TransformationType.FromValue\n   * 4: TransformationType.MapWith\n   * 5: TransformationType.ConvertUsing\n   * 7: TransformationType.NullSubstitution\n   */\n  if (isThisMemberMap<NullSubstitutionFunction>(mapFn, 7)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj, sourceMemberPath);\n  } else if (isThisMemberMap<ConditionFunction>(mapFn, 2)) {\n    value = mapFn[MemberMapFunctionId.fn](\n      sourceObj,\n      defaultValue,\n      sourceMemberPath\n    );\n  } else if (isThisMemberMap<MapFromFunction>(mapFn, 1)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj, destination);\n  } else if (isThisMemberMap<MapWithFunction>(mapFn, 4)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj, mappingStorage);\n  } else if (isThisMemberMap<ConvertUsingFunction>(mapFn, 5)) {\n    value = mapFn[MemberMapFunctionId.fn](sourceObj);\n  } else if (isThisMemberMap<FromValueFunction>(mapFn, 3)) {\n    value = mapFn[MemberMapFunctionId.fn]();\n  } else if (isThisMemberMap<IgnoreFunction>(mapFn, 0)) {\n    value = defaultValue;\n  } else {\n    const memberMapFunction = mapFn[MemberMapFunctionId.fn](\n      sourceObj,\n      sourceMemberPath\n    );\n    value = mapMember(\n      memberMapFunction,\n      sourceObj,\n      sourceMemberPath,\n      destination,\n      mappingStorage,\n      defaultValue\n    );\n  }\n\n  return value;\n}\n\nexport function map<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  sourceObj: TSource,\n  mapping: Mapping<TSource, TDestination>,\n  options: MapOptions<TSource, TDestination>,\n  mappingStorage: MappingStorage,\n  isArrayMap: boolean = false\n): TDestination {\n  const [\n    [sourceModel, destinationModel],\n    [useUndefined, sourceConvention, destinationConvention],\n    props,\n    actions,\n  ] = mapping as Required<Mapping<TSource, TDestination>>;\n\n  /**\n   * If sourceObj is a POJO (plain object)\n   * then instantiate it to become an instance of sourceModel\n   */\n  if (!(sourceObj instanceof sourceModel)) {\n    sourceObj = instantiate(sourceModel, sourceObj);\n  }\n\n  const defaultEmptyValue = useUndefined ? undefined : null;\n  const [beforeAction, afterAction] = actions;\n  const { skipUnmappedAssertion, beforeMap, afterMap } = options;\n  const configKeys: string[] = [];\n\n  const destination = instantiate(destinationModel);\n\n  if (!isArrayMap) {\n    if (beforeMap) {\n      beforeMap(sourceObj, destination, { ...mapping } as any);\n    } else if (beforeAction) {\n      beforeAction(sourceObj, destination, { ...mapping } as any);\n    }\n  }\n\n  let i = props.length;\n  while (i--) {\n    const [memberPath, { transformation }] = props[i];\n    configKeys.push(memberPath);\n\n    if (transformation.preCond && !transformation.preCond[0](sourceObj)) {\n      set(\n        destination,\n        memberPath,\n        transformation.preCond[1] ?? defaultEmptyValue\n      );\n      continue;\n    }\n\n    const sourceMemberPath = getSourcePropertyKey(\n      [sourceConvention, destinationConvention],\n      memberPath\n    );\n\n    // 6: TransformationType.MapInitialize\n    if (isThisMemberMap<MapInitializeFunction>(transformation.mapFn, 6)) {\n      const mapInitializeValue = transformation.mapFn[MemberMapFunctionId.fn](\n        sourceObj\n      );\n      if (mapInitializeValue == null) {\n        set(destination, memberPath, defaultEmptyValue);\n        continue;\n      }\n\n      if (mapInitializeValue instanceof Date) {\n        set(destination, memberPath, new Date(mapInitializeValue));\n        continue;\n      }\n\n      if (Array.isArray(mapInitializeValue)) {\n        const first = mapInitializeValue[0];\n        if (typeof first !== 'object') {\n          set(destination, memberPath, mapInitializeValue.slice());\n          continue;\n        }\n\n        if (isEmpty(first)) {\n          set(destination, memberPath, []);\n          continue;\n        }\n\n        const nestedMapping = getMappingForNestedKey(\n          destinationModel,\n          memberPath as keyof TDestination,\n          first.constructor,\n          mappingStorage\n        );\n        set(\n          destination,\n          memberPath,\n          mapArray(\n            mapInitializeValue,\n            nestedMapping,\n            { skipUnmappedAssertion: options.skipUnmappedAssertion },\n            mappingStorage\n          )\n        );\n        continue;\n      }\n\n      if (\n        (typeof mapInitializeValue === 'object' ||\n          typeof mapInitializeValue === 'function') &&\n        isClass(mapInitializeValue)\n      ) {\n        const nestedMapping = getMappingForDestination(\n          get(destination, null, memberPath).constructor,\n          mapInitializeValue.constructor,\n          mappingStorage\n        ) as Mapping;\n        set(\n          destination,\n          memberPath,\n          map(\n            mapInitializeValue,\n            nestedMapping,\n            { skipUnmappedAssertion: options.skipUnmappedAssertion },\n            mappingStorage\n          )\n        );\n        continue;\n      }\n\n      set(destination, memberPath, mapInitializeValue);\n      continue;\n    }\n\n    set(\n      destination,\n      memberPath,\n      mapMember(\n        transformation.mapFn,\n        sourceObj,\n        sourceMemberPath,\n        destination,\n        mappingStorage,\n        defaultEmptyValue\n      )\n    );\n  }\n\n  if (!isArrayMap) {\n    if (afterMap) {\n      afterMap(sourceObj, destination, { ...mapping } as any);\n    } else if (afterAction) {\n      afterAction(sourceObj, destination, { ...mapping } as any);\n    }\n  }\n\n  if (!skipUnmappedAssertion) {\n    const unmappedKeys = Object.keys(destination).filter(\n      k => !configKeys.includes(k)\n    );\n    if (unmappedKeys.length > 0) {\n      throw new Error(`\nError mapping:\n- Source: ${sourceModel.toString()}\n- Destination: ${destinationModel.toString()}\n\nUnmapped properties:\n-------------------\n${unmappedKeys.join(',\\n')}\n`);\n    }\n  }\n  return destination;\n}\n\nexport function mapArray<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(\n  sourceArray: TSource[],\n  mapping: Mapping<TSource, TDestination>,\n  options: MapOptions<TSource[], TDestination[]>,\n  mappingStorage: MappingStorage\n): TDestination[] {\n  let destination: TDestination[] = [];\n  const { beforeMap, afterMap } = options;\n\n  if (beforeMap) {\n    beforeMap(sourceArray, destination, { ...mapping });\n  }\n\n  for (let i = 0, len = sourceArray.length; i < len; i++) {\n    destination.push(\n      map(\n        sourceArray[i],\n        mapping,\n        { skipUnmappedAssertion: options.skipUnmappedAssertion },\n        mappingStorage,\n        true\n      )\n    );\n  }\n\n  if (afterMap) {\n    afterMap(sourceArray, destination, { ...mapping });\n  }\n\n  return destination;\n}\n","import { Constructible } from '../types';\nimport { storeMetadata } from '../utils';\n\nexport class MetadataExplorer {\n  private static readonly metadataTrackMap = new Map();\n  private static readonly AUTOMAPPER_METADATA_FACTORY =\n    '__NARTC_AUTOMAPPER_METADATA_FACTORY';\n\n  static explore(source: Constructible, destination: Constructible): void {\n    this.exploreInternal(source);\n    this.exploreInternal(destination);\n  }\n\n  private static exploreInternal(model: Constructible): void {\n    if (!model.prototype || this.metadataTrackMap.has(model)) {\n      return;\n    }\n\n    const factory = model[this.AUTOMAPPER_METADATA_FACTORY];\n    if (!factory) {\n      return;\n    }\n\n    const metadata = factory();\n    const metadataEntries: [string, () => any][] = Object.entries(metadata);\n    let i = metadataEntries.length;\n    if (!i) {\n      return;\n    }\n\n    while (i--) {\n      const [key, value] = metadataEntries[i];\n      if (!value) {\n        storeMetadata(model, 'String', key);\n        continue;\n      }\n\n      const meta = value();\n      const metaName = meta.prototype.constructor.name;\n      storeMetadata(model, metaName, key, meta);\n    }\n\n    this.metadataTrackMap.set(model, 1);\n  }\n}\n","import 'reflect-metadata';\nimport { defaultNamingConvention } from './conventions';\nimport {\n  createMapFluentFunction,\n  createMappingObject,\n  getMappingForDestination,\n  getMapProps,\n  map,\n  mapArray,\n} from './core';\nimport { ErrorHandler } from './error-handler';\nimport { MetadataExplorer } from './explorers';\nimport { MappingStorage, ProfileStorage } from './storages';\nimport { instanceStorage } from './storages/instance.storage';\nimport {\n  AutoMapperGlobalSettings,\n  BaseOf,\n  Constructible,\n  CreateMapFluentFunction,\n  CreateMapOptions,\n  Dict,\n  MapOptions,\n  Mapping,\n  MappingProfile,\n  NamingConvention,\n} from './types';\n\nexport class AutoMapper {\n  private readonly _mappingStorage = new MappingStorage();\n  private readonly _profileStorage = new ProfileStorage();\n\n  private defaultGlobalSettings!: [\n    boolean,\n    boolean,\n    Constructible<NamingConvention>,\n    Constructible<NamingConvention>\n  ];\n\n  constructor() {\n    this.setDefault();\n  }\n\n  /**\n   * Provide global naming conventions and useUndefined to the models\n   *\n   * @param {AutoMapperGlobalSettings} settings\n   */\n  withGlobalSettings(settings: AutoMapperGlobalSettings): AutoMapper {\n    const {\n      useUndefined,\n      skipUnmappedAssertion,\n      sourceNamingConvention,\n      destinationNamingConvention,\n      throwError,\n    } = settings;\n\n    this.defaultGlobalSettings[0] = useUndefined ?? false;\n    this.defaultGlobalSettings[1] = skipUnmappedAssertion ?? false;\n\n    if (sourceNamingConvention) {\n      this.defaultGlobalSettings[2] = sourceNamingConvention;\n    }\n\n    if (destinationNamingConvention) {\n      this.defaultGlobalSettings[3] = destinationNamingConvention;\n    }\n\n    if (throwError != null) {\n      ErrorHandler.setShouldThrow(throwError);\n    }\n\n    return this;\n  }\n\n  /**\n   * Add a Profile to this AutoMapper instance\n   * @param {MappingProfile} profile\n   */\n  addProfile(profile: new (mapper: AutoMapper) => MappingProfile): AutoMapper {\n    this._profileStorage.add(this, new profile(this));\n    return this;\n  }\n\n  /**\n   * Create a mapping between a Source and a Destination with an optional Options\n   *\n   * @param {Constructible} source\n   * @param {Constructible} destination\n   * @param {CreateMapOptions} options - Provide inheritance and naming conventions for this Mapping\n   */\n  createMap<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any,\n    TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n    TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n  >(\n    source: Constructible<TSource>,\n    destination: Constructible<TDestination>,\n    options?: CreateMapOptions<\n      TSource,\n      TDestination,\n      TBaseSource,\n      TBaseDestination\n    >\n  ): CreateMapFluentFunction<TSource, TDestination> {\n    MetadataExplorer.explore(source, destination);\n    const mergeOptions: CreateMapOptions<\n      TSource,\n      TDestination,\n      TBaseSource,\n      TBaseDestination\n    > = {\n      useUndefined: this.defaultGlobalSettings[0],\n      sourceMemberNamingConvention: this.defaultGlobalSettings[2],\n      destinationMemberNamingConvention: this.defaultGlobalSettings[3],\n      ...options,\n    };\n    const mapping = createMappingObject(\n      source,\n      destination,\n      mergeOptions,\n      this._mappingStorage\n    );\n    return createMapFluentFunction(mapping, mergeOptions, this._mappingStorage);\n  }\n\n  /**\n   * Map a sourceObj to the Destination with Source model provided.\n   * Usually used to map plain object of Source instead of an instance of Source.\n   *\n   * @example\n   * ```typescript\n   * const user = this.db.findOne(...).toJSON();\n   * Mapper.map(user, UserVm, User);\n   * ```\n   *\n   * @param {object} sourceObj\n   * @param {Constructible} destination\n   * @param {Constructible} source\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  map<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource, TDestination>\n  ): TDestination;\n  /**\n   * Map a sourceObj to the Destination with an optional Options provided.\n   *\n   * @param {object} sourceObj\n   * @param {Constructible} destination\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  map<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource, TDestination>\n  ): TDestination;\n  map<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceObj: TSource, ...args: any[]): TDestination {\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceObj.constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n    return map(sourceObj, mapping, options, this._mappingStorage);\n  }\n\n  /**\n   * Async version of map()\n   */\n  mapAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource, TDestination>\n  ): Promise<TDestination>;\n  /**\n   * Async version of map()\n   */\n  mapAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceObj: TSource,\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource, TDestination>\n  ): Promise<TDestination>;\n  mapAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceObj: TSource, ...args: any[]): Promise<TDestination> {\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceObj.constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n    return Promise.resolve().then(() =>\n      map(sourceObj, mapping, options, this._mappingStorage)\n    );\n  }\n\n  /**\n   * Map a sourceArr to an array of Destination with Source model provided.\n   * Usually used to map plain array of Source instead of an instance of Source.\n   *\n   * @example\n   * ```typescript\n   * const user = this.db.findOne(...).toJSON();\n   * Mapper.map(user, UserVm, User);\n   * ```\n   *\n   * @param {Array} sourceArr\n   * @param {Constructible} destination\n   * @param {Constructible} source\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  mapArray<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): TDestination[];\n  /**\n   * Map a sourceArr to an Array of Destination with an optional Options provided.\n   *\n   * @param {Array} sourceArr\n   * @param {Constructible} destination\n   * @param {MapOptions} options - Provide callbacks for this map operation\n   */\n  mapArray<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): TDestination[];\n  mapArray<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceArr: TSource[], ...args: any[]): TDestination[] {\n    if (!sourceArr.length) {\n      return [];\n    }\n\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceArr[0].constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n\n    return mapArray(sourceArr, mapping, options, this._mappingStorage);\n  }\n\n  /**\n   * Async version of mapArray()\n   */\n  mapArrayAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    source?: Constructible<TSource>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): Promise<TDestination[]>;\n  /**\n   * Async version of mapArray()\n   */\n  mapArrayAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    sourceArr: TSource[],\n    destination: Constructible<TDestination>,\n    options?: MapOptions<TSource[], TDestination[]>\n  ): Promise<TDestination[]>;\n  mapArrayAsync<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(sourceArr: TSource[], ...args: any[]): Promise<TDestination[]> {\n    if (!sourceArr.length) {\n      return Promise.resolve().then(() => []);\n    }\n\n    const [destination, options, source] = getMapProps(\n      args,\n      this.defaultGlobalSettings[1]\n    );\n    const mapping = getMappingForDestination(\n      destination,\n      source || (sourceArr[0].constructor as Constructible<TSource>),\n      this._mappingStorage\n    ) as Mapping;\n\n    return Promise.resolve().then(() =>\n      mapArray(sourceArr, mapping, options, this._mappingStorage)\n    );\n  }\n\n  /**\n   * Retrieve the mapping of a Source and a Destination\n   *\n   * @param {Constructible} source\n   * @param {Constructible} destination\n   */\n  getMapping<\n    TSource extends Dict<TSource> = any,\n    TDestination extends Dict<TDestination> = any\n  >(\n    source: Constructible<TSource>,\n    destination: Constructible<TDestination>\n  ): Mapping<TSource, TDestination> | undefined {\n    return this._mappingStorage.get(source, destination);\n  }\n\n  /**\n   * Dispose of all Mappings and Profiles on the AutoMapper instance\n   */\n  dispose(): void {\n    this.setDefault();\n    this._mappingStorage.dispose();\n    instanceStorage.dispose();\n  }\n\n  /**\n   * Retrieve the current instance of the MappingStorage on the AutoMapper instance\n   */\n  get mappingStorage(): MappingStorage {\n    return this._mappingStorage;\n  }\n\n  /**\n   * Retrieve the current instance of the ProfileStorage on the AutoMapper instance\n   */\n  get profileStorage(): ProfileStorage {\n    return this._profileStorage;\n  }\n\n  private setDefault() {\n    this._profileStorage.initialize(this);\n    this.defaultGlobalSettings = [\n      false,\n      false,\n      defaultNamingConvention,\n      defaultNamingConvention,\n    ];\n  }\n}\n\nexport const Mapper = new AutoMapper();\n","import { MappingStorage } from '../storages';\nimport {\n  BaseOf,\n  CreateMapFluentFunction,\n  CreateMapOptions,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MemberMapFunction,\n  PreConditionFunction,\n  Selector,\n  SelectorReturn,\n} from '../types';\nimport { createMapForMember } from './create-map-for-member';\nimport { createReverseMapFluentFunction } from './create-reverse-map-fluent-function';\nimport { createReverseMappingObject } from './create-reverse-mapping-object';\nimport { getMappingForDestination } from './get-mapping-for-destination';\nimport { inheritBaseMapping } from './inherit-base-mapping';\n\nexport function createMapFluentFunction<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>,\n  options: CreateMapOptions<\n    TSource,\n    TDestination,\n    TBaseSource,\n    TBaseDestination\n  >,\n  mappingStorage: MappingStorage\n): CreateMapFluentFunction<TSource, TDestination> {\n  if (options.includeBase?.length) {\n    const [baseSource, baseDestination] = options.includeBase;\n    const baseMapping = getMappingForDestination(\n      baseDestination,\n      baseSource,\n      mappingStorage,\n      true\n    );\n    if (baseMapping != null) {\n      inheritBaseMapping(mapping, baseMapping);\n    }\n  }\n\n  const fluentFunction: CreateMapFluentFunction<TSource, TDestination> = {\n    forMember: <TMemberType = SelectorReturn<TDestination>>(\n      selector: Selector<TDestination, TMemberType>,\n      ...functions: [\n        (\n          | ReturnType<PreConditionFunction<TSource, TDestination, TMemberType>>\n          | ReturnType<MemberMapFunction<TSource, TDestination, TMemberType>>\n        ),\n        ReturnType<MemberMapFunction<TSource, TDestination, TMemberType>>?\n      ]\n    ) =>\n      createMapForMember<\n        TSource,\n        TDestination,\n        Selector<TDestination, TMemberType>,\n        typeof fluentFunction\n      >(mapping, selector, functions, fluentFunction),\n    beforeMap: action => {\n      mapping[MappingClassId.actions][0] = action;\n      return fluentFunction;\n    },\n    afterMap: action => {\n      mapping[MappingClassId.actions][1] = action;\n      return fluentFunction;\n    },\n    reverseMap: () =>\n      createReverseMapFluentFunction(\n        createReverseMappingObject(mapping, mappingStorage)\n      ),\n  };\n\n  return fluentFunction;\n}\n","import {\n  BaseOf,\n  CreateReversedMapFluentFunction,\n  Dict,\n  Mapping,\n  MappingClassId,\n  MemberMapFunction,\n  PreConditionFunction,\n  Selector,\n  SelectorReturn,\n} from '../types';\nimport { createMapForMember } from './create-map-for-member';\n\nexport function createReverseMapFluentFunction<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TDestination, TSource, TBaseDestination, TBaseSource>\n): CreateReversedMapFluentFunction<TDestination, TSource> {\n  const reversedMapFluentFunction: CreateReversedMapFluentFunction<\n    TDestination,\n    TSource\n  > = {\n    forPath: (\n      selector: Selector<TSource, SelectorReturn<TSource>>,\n      ...functions: [\n        (\n          | ReturnType<PreConditionFunction<TDestination, TSource>>\n          | ReturnType<MemberMapFunction<TDestination, TSource>>\n        ),\n        ReturnType<MemberMapFunction<TDestination, TSource>>?\n      ]\n    ) =>\n      createMapForMember(\n        mapping,\n        selector,\n        functions as any,\n        reversedMapFluentFunction\n      ),\n    beforeMap: action => {\n      mapping[MappingClassId.actions][0] = action;\n      return reversedMapFluentFunction;\n    },\n    afterMap: action => {\n      mapping[MappingClassId.actions][1] = action;\n      return reversedMapFluentFunction;\n    },\n  };\n\n  return reversedMapFluentFunction;\n}\n","import { MappingStorage } from '../storages';\nimport { BaseOf, Constructible, Dict, Mapping, MappingClassId } from '../types';\nimport { getMappingForDestination } from './get-mapping-for-destination';\nimport { inheritBaseMapping } from './inherit-base-mapping';\nimport { initializeReverseMappingProps } from './initialize-reverse-mapping-props';\n\nexport function createReverseMappingObject<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  mapping: Mapping<TSource, TDestination, TBaseSource, TBaseDestination>,\n  mappingStorage: MappingStorage\n): Mapping<TDestination, TSource, TBaseDestination, TBaseSource> {\n  const [source, destination] = mapping[MappingClassId.models];\n  const [useUndefined, sourceConvention, destinationConvention] = mapping[\n    MappingClassId.conventions\n  ];\n  const bases = mapping[MappingClassId.bases];\n\n  let reversedMapping = mappingStorage.get(destination, source);\n  if (reversedMapping) {\n    return reversedMapping;\n  }\n\n  reversedMapping = [\n    [destination, source],\n    [useUndefined, destinationConvention, sourceConvention],\n    initializeReverseMappingProps(mapping),\n    [],\n    (bases?.slice().reverse() || []) as [Constructible, Constructible],\n  ];\n\n  const reversedBaseMapping = getMappingForDestination(\n    reversedMapping[MappingClassId.bases]![1],\n    reversedMapping[MappingClassId.bases]![0],\n    mappingStorage,\n    true\n  );\n  if (reversedBaseMapping) {\n    inheritBaseMapping(reversedMapping, reversedBaseMapping);\n  }\n\n  mappingStorage.set(destination, source, reversedMapping);\n  return reversedMapping;\n}\n","import { ErrorHandler } from '../error-handler';\nimport { MappingStorage } from '../storages';\nimport {\n  BaseOf,\n  Constructible,\n  CreateMapOptions,\n  Dict,\n  Mapping,\n} from '../types';\nimport { initializeMappingProps } from './initialize-mapping-props';\n\nexport function createMappingObject<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TBaseSource extends BaseOf<TSource, TBaseSource> = any,\n  TBaseDestination extends BaseOf<TDestination, TBaseDestination> = any\n>(\n  source: Constructible<TSource>,\n  destination: Constructible<TDestination>,\n  options: CreateMapOptions<\n    TSource,\n    TDestination,\n    TBaseSource,\n    TBaseDestination\n  >,\n  mappingStorage: MappingStorage\n) {\n  if (mappingStorage.has(source, destination)) {\n    ErrorHandler.handleError(\n      `Mapping for source ${source.toString()} and destination ${destination.toString()} already exists`\n    );\n  }\n\n  const mapping: Mapping<\n    TSource,\n    TDestination,\n    TBaseSource,\n    TBaseDestination\n  > = [\n    [source, destination],\n    [\n      options.useUndefined!,\n      options.sourceMemberNamingConvention!,\n      options.destinationMemberNamingConvention!,\n    ],\n    [],\n    [],\n  ];\n  initializeMappingProps(mapping);\n  mappingStorage.set(source, destination, mapping);\n  return mapping;\n}\n","import { mapInitialize } from '../member-functions/map-initialize';\nimport { Dict, Mapping, MappingClassId } from '../types';\nimport { getSourcePropertyKey, isClass } from '../utils';\nimport { instantiate } from './instantiate';\n\nexport function initializeMappingProps<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any\n>(mapping: Mapping<TSource, TDestination>): void {\n  const [srcModel, destModel] = mapping[MappingClassId.models];\n  const destination = instantiate(destModel);\n  let source = instantiate(srcModel);\n  const sourceProtoConstructor = Object.getPrototypeOf(source.constructor);\n  if (sourceProtoConstructor.name) {\n    source = Object.assign(source, instantiate(sourceProtoConstructor));\n  }\n\n  const sourceProto = Object.getPrototypeOf(source);\n  const destinationPaths = getPathRecursive(destination);\n  const [\n    useUndefined,\n    sourceNamingConvention,\n    destinationNamingConvention,\n  ] = mapping[MappingClassId.conventions];\n  let i = destinationPaths.length;\n  while (i--) {\n    const path = destinationPaths[i];\n    const sourcePath = getSourcePropertyKey(\n      [sourceNamingConvention, destinationNamingConvention],\n      path\n    );\n    const dottedSourcePaths = sourcePath.split('.');\n    if (\n      dottedSourcePaths.length > 1 &&\n      (!source.hasOwnProperty(dottedSourcePaths[0]) ||\n        ((source as any)[dottedSourcePaths[0]] &&\n          isClass((source as any)[dottedSourcePaths[0]])))\n    ) {\n      continue;\n    }\n\n    const defaultVal = useUndefined ? undefined : null;\n    if (\n      !source.hasOwnProperty(sourcePath) &&\n      !sourceProto.hasOwnProperty(sourcePath)\n    ) {\n      const convention = new sourceNamingConvention();\n      const [first, ...paths] = sourcePath\n        .split(convention.splittingExpression)\n        .filter(Boolean)\n        .filter(p => p !== '.');\n      if (!paths.length || !source.hasOwnProperty(first)) {\n        continue;\n      }\n\n      const sourceMemberPath = [\n        [first]\n          .concat(paths.map(p => convention.transformPropertyName([p])))\n          .join('.'),\n      ];\n\n      if (paths.length > 1) {\n        sourceMemberPath.push(\n          [first].concat(convention.transformPropertyName(paths)).join('.')\n        );\n      }\n\n      mapping[MappingClassId.props].push([\n        path,\n        Object.seal({\n          paths: [path],\n          transformation: {\n            type: 6, // 6: TransformationType.MapInitialize.\n            preCond: undefined,\n            mapFn: mapInitialize(defaultVal, ...sourceMemberPath),\n          },\n        }),\n      ]);\n      continue;\n    }\n\n    mapping[MappingClassId.props].push([\n      path,\n      Object.seal({\n        paths: [path, sourcePath],\n        transformation: {\n          type: 6, // 6: TransformationType.MapInitialize.\n          preCond: undefined,\n          mapFn: mapInitialize(defaultVal, sourcePath),\n        },\n      }),\n    ]);\n  }\n}\n\nfunction getPathRecursive(node: any, prefix: string = '', prev?: string[]) {\n  let result: string[] = prev || [];\n\n  const keys = Object.getOwnPropertyNames(node);\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n    const path = prefix + key;\n    result.push(path);\n\n    const child = node[key];\n    if (typeof child === 'object') {\n      let queue = [child];\n      if (Array.isArray(child)) {\n        queue = child;\n      }\n\n      for (const childNode of queue) {\n        const childPaths = getPathRecursive(childNode, path + '.');\n        for (const childPath of childPaths) {\n          result.push(childPath);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { metadataStorage } from '../storages';\nimport { instanceStorage } from '../storages/instance.storage';\nimport { Constructible, MetadataFunction } from '../types';\nimport { storeMetadata } from '../utils';\n\nexport const AutoMap = (\n  typeFn?: () => Function,\n  depth: number = 0\n): PropertyDecorator => (target, propertyKey) => {\n  if (typeFn) {\n    metadataStorage.addMetadata(target.constructor as Constructible, [\n      [propertyKey, typeFn as MetadataFunction],\n    ]);\n    instanceStorage.set(\n      target.constructor as Constructible,\n      propertyKey,\n      depth\n    );\n  } else {\n    let meta = Reflect.getMetadata('design:type', target, propertyKey);\n    if (meta) {\n      storeMetadata(\n        target.constructor as Constructible,\n        meta.prototype.constructor.name,\n        propertyKey as string\n      );\n    }\n  }\n};\n","import { MappingProfile } from './types';\n\nexport abstract class ProfileBase implements MappingProfile {\n  profileName: string;\n\n  protected constructor() {\n    this.profileName = this.constructor.name;\n  }\n}\n","import {\n  ConditionFunction,\n  ConditionPredicate,\n  Dict,\n  SelectorReturn,\n} from '../types';\nimport { get } from '../utils';\n\nexport function condition<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  predicate: ConditionPredicate<TSource>,\n  defaultValue?: TSelectorReturn\n): ReturnType<ConditionFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    2, // 2: TransformationType.Condition\n    null,\n    (source, internalDefaultValue: undefined | null, ...sourceMemberPaths) => {\n      if (predicate(source)) {\n        return get(source, internalDefaultValue, ...sourceMemberPaths);\n      }\n\n      return defaultValue || internalDefaultValue;\n    },\n  ];\n}\n","import {\n  Converter,\n  ConvertUsingFunction,\n  Dict,\n  Selector,\n  SelectorReturn,\n} from '../types';\n\nexport function convertUsing<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>,\n  TConvertSource = TSource\n>(\n  converter: Converter<TConvertSource, TSelectorReturn>,\n  value?: Selector<TSource, TConvertSource>\n): ReturnType<ConvertUsingFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    5, // 5: TransformationType.ConvertUsing\n    null,\n    source => {\n      let valueToConvert: TConvertSource;\n      if (value) {\n        valueToConvert = value(source);\n      } else {\n        valueToConvert = (source as unknown) as TConvertSource;\n      }\n      return converter.convert(valueToConvert);\n    },\n  ];\n}\n","import {\n  Constructible,\n  CreateMapMetadataFunction,\n  Dict,\n  MetadataOptions,\n} from './types';\nimport { storeMetadata } from './utils';\n\nexport const createMapMetadata: CreateMapMetadataFunction = <\n  TModel extends Dict<TModel> = any\n>(\n  model: Constructible<TModel>,\n  metadataOptions: MetadataOptions<TModel>\n) => {\n  const entries = Object.entries(metadataOptions);\n\n  let i = entries.length;\n  if (!i) {\n    return;\n  }\n  while (i--) {\n    const [key, metadata]: [string, any] = entries[i];\n    const metadataName =\n      metadata.prototype?.constructor.name || metadata.constructor.name;\n    storeMetadata(model, metadataName, key, metadata);\n  }\n};\n","import { Dict, FromValueFunction, SelectorReturn } from '../types';\n\nexport function fromValue<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  rawValue: TSelectorReturn\n): ReturnType<FromValueFunction<TSource, TDestination, TSelectorReturn>> {\n  // 3: TransformationType.FromValue\n  return [3, null, () => rawValue];\n}\n","import { IgnoreFunction } from '../types';\n\nexport function ignore(): ReturnType<IgnoreFunction> {\n  // 0: TransformationType.Ignore\n  return [0, null, () => {}];\n}\n","import {\n  DeferFunction,\n  Dict,\n  MapDeferFunction,\n  SelectorReturn,\n} from '../types';\n\nexport function mapDefer<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  defer: DeferFunction<TSource, TDestination, TSelectorReturn>\n): ReturnType<MapDeferFunction<TSource, TDestination, TSelectorReturn>> {\n  // 8: TransformationType.MapDefer\n  return [8, null, defer];\n}\n","import {\n  Dict,\n  MapFromFunction,\n  Resolver,\n  SelectorReturn,\n  ValueSelector,\n} from '../types';\n\nexport function mapFrom<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  from:\n    | ValueSelector<TSource, TDestination, TSelectorReturn>\n    | Resolver<TSource, TDestination, TSelectorReturn>\n): ReturnType<MapFromFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    1, // 1: TransformationType.MapFrom\n    from as ValueSelector<TSource, TDestination, TSelectorReturn>,\n    (source, destination) => {\n      if (isResolver(from)) {\n        return from.resolve(source, destination);\n      }\n\n      return from(source);\n    },\n  ];\n}\n\nfunction isResolver(fn: ValueSelector | Resolver<any>): fn is Resolver<any> {\n  return 'resolve' in fn;\n}\n","import { getMappingForDestination, map, mapArray } from '../core';\nimport {\n  Constructible,\n  Dict,\n  Mapping,\n  MapWithFunction,\n  SelectorReturn,\n  Unpacked,\n  ValueSelector,\n} from '../types';\nimport { isClass, isEmpty } from '../utils';\n\nexport function mapWith<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  withDestination: Constructible<Unpacked<TSelectorReturn>>,\n  withValue: ValueSelector<TSource>,\n  valueModel?: () => Constructible\n): ReturnType<MapWithFunction<TSource, TDestination, TSelectorReturn>> {\n  return [\n    4, // 4: TransformationType.MapFrom\n    withValue,\n    (source, mappingStorage) => {\n      const sourceValue = withValue(source);\n      if (Array.isArray(sourceValue)) {\n        if (isEmpty(sourceValue[0])) {\n          return [];\n        }\n\n        const mapping = getMappingForDestination(\n          withDestination,\n          valueModel?.() || sourceValue[0].constructor,\n          mappingStorage\n        ) as Mapping;\n        return mapArray(\n          sourceValue,\n          mapping,\n          { skipUnmappedAssertion: true },\n          mappingStorage\n        ) as any;\n      }\n\n      if (isEmpty(sourceValue)) {\n        return null;\n      }\n\n      if (!isClass(sourceValue)) {\n        console.warn(\n          `MapWith was invoked with a primitive. No mapping was executed`\n        );\n        return null;\n      }\n\n      const mapping = getMappingForDestination(\n        withDestination,\n        valueModel?.() || sourceValue.constructor,\n        mappingStorage\n      ) as Mapping;\n      return map(\n        sourceValue,\n        mapping,\n        { skipUnmappedAssertion: true },\n        mappingStorage\n      ) as TSelectorReturn;\n    },\n  ];\n}\n","import { Dict, NullSubstitutionFunction, SelectorReturn } from '../types';\nimport { get } from '../utils';\n\nexport function nullSubstitution<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  substitution: TSelectorReturn\n): ReturnType<\n  NullSubstitutionFunction<TSource, TDestination, TSelectorReturn>\n> {\n  return [\n    7, // 7: TransformationType.NullSubstitution\n    null,\n    (source, ...sourceMemberPaths) =>\n      get(source, substitution, ...sourceMemberPaths),\n  ];\n}\n","import {\n  ConditionPredicate,\n  Dict,\n  PreConditionFunction,\n  SelectorReturn,\n} from '../types';\n\nexport function preCondition<\n  TSource extends Dict<TSource> = any,\n  TDestination extends Dict<TDestination> = any,\n  TSelectorReturn = SelectorReturn<TDestination>\n>(\n  predicate: ConditionPredicate<TSource>,\n  defaultValue?: TSelectorReturn\n): ReturnType<PreConditionFunction<TSource, TDestination, TSelectorReturn>> {\n  return [source => predicate(source), defaultValue];\n}\n"],"names":["CamelCaseNamingConvention","transformPropertyName","sourceNameParts","result","i","len","length","charAt","toLowerCase","toUpperCase","substr","SnakeCaseNamingConvention","sourcePropNameParts","map","p","join","this","separatorCharacter","PascalCaseNamingConvention","defaultNamingConvention","ErrorHandler","setShouldThrow","shouldThrow","handleError","errorMessage","Error","console","warn","NestStorage","storage","WeakMap","set","key","nestedKey","value","setInternal","get","getInternal","has","hasInternal","_storage$get","WeakMapNestedStorage","_NestStorage","dispose","MapNestedStorage","_NestStorage2","Map","MappingStorage","_WeakMapNestedStorage","metadataStorage","getMetadata","model","metadataMapList","_metadataMap","proto","Object","getPrototypeOf","some","push","getMetadataForKey","find","addMetadata","metadata","existingMetadata","existingProtoMetadata","name","existingMeta","ProfileStorage","profiles","initialize","mapper","add","profile","profileName","instanceStorage","recursiveCounts","getDepthAndCount","parent","member","getCount","setCount","count","resetCount","resetAllCount","clear","storeMetadata","metaName","metaKey","metaValue","Date","isEmpty","Array","isArray","keys","isClass","fn","typeOfFn","constructorFnString","constructor","_fn$constructor","toString","test","includes","isThisMemberMap","mapFn","types","type","object","defaultVal","_getInternal","path","_val","split","filter","Boolean","reduce","obj","paths","val","getSourcePropertyKey","sourceNamingConvention","destinationNamingConvention","splitPath","destNamingConvention","srcNamingConvention","keyParts","splittingExpression","getMemberPath","fnString","substring","indexOf","replace","es5Match","match","mapInitialize","source","instantiate","defaultValue","instance","assign","metaResult","meta","undefined","prototype","v","depth","getMappingForDestination","destination","mappingStorage","isInherit","mapping","inheritBaseMapping","baseMapping","props","baseProps","basePropKey","propFromBase","seal","existProp","initializeReverseMappingProps","reversedProps","transformation","destPath","sourcePath","hasOwnProperty","preCond","createMapForMember","selector","fluentFunction","mapMemberFn","memberPath","mappingProperty","getMappingForNestedKey","destinationConstructor","destinationMemberKey","sourceConstructor","getMapProps","args","skipUnmappedAssertion","defaultOptions","beforeMap","afterMap","temp","mapMember","sourceObj","sourceMemberPath","options","isArrayMap","sourceModel","destinationModel","useUndefined","sourceConvention","destinationConvention","actions","defaultEmptyValue","beforeAction","afterAction","configKeys","mapInitializeValue","first","slice","nestedMapping","mapArray","unmappedKeys","k","sourceArray","MetadataExplorer","explore","exploreInternal","metadataTrackMap","factory","AUTOMAPPER_METADATA_FACTORY","metadataEntries","entries","AutoMapper","setDefault","withGlobalSettings","settings","throwError","defaultGlobalSettings","addProfile","_profileStorage","createMap","mergeOptions","sourceMemberNamingConvention","destinationMemberNamingConvention","includeBase","_options$includeBase","forMember","functions","action","reverseMap","reversedMapFluentFunction","forPath","createReverseMapFluentFunction","bases","reversedMapping","reversedBaseMapping","reverse","createReverseMappingObject","createMapFluentFunction","srcModel","sourceProtoConstructor","sourceProto","destinationPaths","getPathRecursive","node","prefix","prev","getOwnPropertyNames","child","queue","dottedSourcePaths","convention","concat","initializeMappingProps","createMappingObject","_mappingStorage","mapAsync","Promise","resolve","then","_this","sourceArr","mapArrayAsync","_this2","getMapping","Mapper","typeFn","target","propertyKey","Reflect","predicate","internalDefaultValue","sourceMemberPaths","converter","valueToConvert","convert","metadataOptions","rawValue","defer","from","withDestination","withValue","valueModel","sourceValue","substitution"],"mappings":"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"}